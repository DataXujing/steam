// GENERATED BY crudgen; DON'T EDIT

package sql

import (
	"database/sql"
	"log"
	"time"

	"github.com/pkg/errors"
	"gopkg.in/doug-martin/goqu.v3"
)

var DEBUG bool

// ---------- ------- ----------
// ---------- ------- ----------
// ---------- Cluster ----------
// ---------- ------- ----------
// ---------- ------- ----------

func (ds *Datastore) CreateCluster(name string, clusterTypeId int64, options ...QueryOpt) (int64, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return 0, errors.Wrap(err, "beginning transaction")
	}
	
	var id int64
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("cluster"))
		// Default insert fields
	cluster := goqu.Record{ 
		"name": name, 
		"type_id": clusterTypeId,
		"state": q.state.Starting,
		"created": time.Now(),
	}
	q.AddFields(cluster)
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToInsertSql(q.fields))
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return errors.Wrap(err, "executing query")
	}
	id, err = res.LastInsertId()
	if err != nil {
		return err
	}
	q.result = id
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})

	return id, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadClusters(options ...QueryOpt) ([]Cluster, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return []Cluster{}, errors.Wrap(err, "beginning transaction")
	}

	var clusters []Cluster
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("cluster"))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToSql())
	}
		// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return err
	}
		clusters, err = ScanClusters(rows)
		
	if err != nil {
		return err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})
	
	return clusters, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadCluster(options ...QueryOpt) (Cluster, bool, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return Cluster{}, false, errors.Wrap(err, "beginning transaction")
	}

	var cluster Cluster
	var exists bool
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("cluster"))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToSql())
	}
		// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return err
	}
		cluster, err = ScanCluster(row)
		if err == sql.ErrNoRows {
		return nil
	} else if err == nil {
		exists = true
	}
	if err != nil {
		return err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})

	return cluster, exists, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) UpdateCluster(clusterId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("cluster").Where(goqu.I("id").Eq(clusterId)))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToUpdateSql(q.fields))
	}
	// Execute query
	_, err := q.dataset.Update(q.fields).Exec()
	return errors.Wrap(err, "executing query")
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})

	return errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) DeleteCluster(clusterId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("cluster").Where(goqu.I("id").Eq(clusterId)))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToDeleteSql())
	}
	// Execute query
	_, err := q.dataset.Delete().Exec()
	return errors.Wrap(err, "executing query")
	})

	return errors.Wrap(err, "committing transaction")
}

func createCluster(tx *goqu.TxDatabase, name string, clusterTypeId int64, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("cluster"))
	// Default insert fields
	cluster := goqu.Record{ 
		"name": name, 
		"type_id": clusterTypeId,
		"state": q.state.Starting,
		"created": time.Now(),
	}
	q.AddFields(cluster)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToInsertSql(q.fields))
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	return res.LastInsertId()
}

func readClusters(tx *goqu.TxDatabase, options ...QueryOpt) ([]Cluster, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("cluster"))
	for _, option := range options {
		if err := option(q); err != nil {
			return []Cluster{}, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []Cluster{}, err
	}
	
	// Scan rows to Clusters
	return ScanClusters(rows)
}

func readCluster(tx *goqu.TxDatabase, options ...QueryOpt) (Cluster, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("cluster"))
	for _, option := range options {
		if err := option(q); err != nil {
			return Cluster{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return Cluster{}, false, err
	}
	ret_cluster, err := ScanCluster(row)
	if err == sql.ErrNoRows {
		return Cluster{}, exists, nil
	} else if err == nil {
		exists = true
	}
	// Scan row to Cluster
	return ret_cluster, exists, err
}

func updateCluster(tx *goqu.TxDatabase, clusterId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("cluster").Where(goqu.I("id").Eq(clusterId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToUpdateSql(q.fields))
	}
	// Execute query
	_, err := q.dataset.Update(q.fields).Exec()
	return errors.Wrap(err, "executing query")
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
}

func deleteCluster(tx *goqu.TxDatabase, clusterId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("cluster").Where(goqu.I("id").Eq(clusterId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToDeleteSql())
	}
	// Execute query
	_, err := q.dataset.Delete().Exec()
	return errors.Wrap(err, "executing query")
}


// ---------- ----------- ----------
// ---------- ----------- ----------
// ---------- ClusterType ----------
// ---------- ----------- ----------
// ---------- ----------- ----------

func (ds *Datastore) CreateClusterType(name string, options ...QueryOpt) (int64, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return 0, errors.Wrap(err, "beginning transaction")
	}
	
	var id int64
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("cluster_type"))
		// Default insert fields
	clusterType := goqu.Record{ 
		"name": name,
	}
	q.AddFields(clusterType)
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToInsertSql(q.fields))
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return errors.Wrap(err, "executing query")
	}
	id, err = res.LastInsertId()
	if err != nil {
		return err
	}
	q.result = id
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})

	return id, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadClusterTypes(options ...QueryOpt) ([]ClusterType, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return []ClusterType{}, errors.Wrap(err, "beginning transaction")
	}

	var clusterTypes []ClusterType
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("cluster_type"))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToSql())
	}
		// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return err
	}
		clusterTypes, err = ScanClusterTypes(rows)
		
	if err != nil {
		return err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})
	
	return clusterTypes, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadClusterType(options ...QueryOpt) (ClusterType, bool, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return ClusterType{}, false, errors.Wrap(err, "beginning transaction")
	}

	var clusterType ClusterType
	var exists bool
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("cluster_type"))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToSql())
	}
		// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return err
	}
		clusterType, err = ScanClusterType(row)
		if err == sql.ErrNoRows {
		return nil
	} else if err == nil {
		exists = true
	}
	if err != nil {
		return err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})

	return clusterType, exists, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) UpdateClusterType(clusterTypeId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("cluster_type").Where(goqu.I("id").Eq(clusterTypeId)))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToUpdateSql(q.fields))
	}
	// Execute query
	_, err := q.dataset.Update(q.fields).Exec()
	return errors.Wrap(err, "executing query")
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})

	return errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) DeleteClusterType(clusterTypeId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("cluster_type").Where(goqu.I("id").Eq(clusterTypeId)))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToDeleteSql())
	}
	// Execute query
	_, err := q.dataset.Delete().Exec()
	return errors.Wrap(err, "executing query")
	})

	return errors.Wrap(err, "committing transaction")
}

func createClusterType(tx *goqu.TxDatabase, name string, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("cluster_type"))
	// Default insert fields
	clusterType := goqu.Record{ 
		"name": name,
	}
	q.AddFields(clusterType)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToInsertSql(q.fields))
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	return res.LastInsertId()
}

func readClusterTypes(tx *goqu.TxDatabase, options ...QueryOpt) ([]ClusterType, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("cluster_type"))
	for _, option := range options {
		if err := option(q); err != nil {
			return []ClusterType{}, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []ClusterType{}, err
	}
	
	// Scan rows to ClusterTypes
	return ScanClusterTypes(rows)
}

func readClusterType(tx *goqu.TxDatabase, options ...QueryOpt) (ClusterType, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("cluster_type"))
	for _, option := range options {
		if err := option(q); err != nil {
			return ClusterType{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return ClusterType{}, false, err
	}
	ret_clusterType, err := ScanClusterType(row)
	if err == sql.ErrNoRows {
		return ClusterType{}, exists, nil
	} else if err == nil {
		exists = true
	}
	// Scan row to ClusterType
	return ret_clusterType, exists, err
}

func updateClusterType(tx *goqu.TxDatabase, clusterTypeId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("cluster_type").Where(goqu.I("id").Eq(clusterTypeId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToUpdateSql(q.fields))
	}
	// Execute query
	_, err := q.dataset.Update(q.fields).Exec()
	return errors.Wrap(err, "executing query")
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
}

func deleteClusterType(tx *goqu.TxDatabase, clusterTypeId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("cluster_type").Where(goqu.I("id").Eq(clusterTypeId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToDeleteSql())
	}
	// Execute query
	_, err := q.dataset.Delete().Exec()
	return errors.Wrap(err, "executing query")
}


// ---------- ----------------- ----------
// ---------- ----------------- ----------
// ---------- ClusterYarnDetail ----------
// ---------- ----------------- ----------
// ---------- ----------------- ----------

func (ds *Datastore) CreateClusterYarnDetail(engineId int64, outputDir string, options ...QueryOpt) (int64, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return 0, errors.Wrap(err, "beginning transaction")
	}
	
	var id int64
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("cluster_yarn_detail"))
		// Default insert fields
	clusterYarnDetail := goqu.Record{ 
		"engine_id": engineId, 
		"output_dir": outputDir,
	}
	q.AddFields(clusterYarnDetail)
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToInsertSql(q.fields))
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return errors.Wrap(err, "executing query")
	}
	id, err = res.LastInsertId()
	if err != nil {
		return err
	}
	q.result = id
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})

	return id, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadClusterYarnDetails(options ...QueryOpt) ([]ClusterYarnDetail, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return []ClusterYarnDetail{}, errors.Wrap(err, "beginning transaction")
	}

	var clusterYarnDetails []ClusterYarnDetail
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("cluster_yarn_detail"))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToSql())
	}
		// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return err
	}
		clusterYarnDetails, err = ScanClusterYarnDetails(rows)
		
	if err != nil {
		return err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})
	
	return clusterYarnDetails, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadClusterYarnDetail(options ...QueryOpt) (ClusterYarnDetail, bool, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return ClusterYarnDetail{}, false, errors.Wrap(err, "beginning transaction")
	}

	var clusterYarnDetail ClusterYarnDetail
	var exists bool
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("cluster_yarn_detail"))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToSql())
	}
		// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return err
	}
		clusterYarnDetail, err = ScanClusterYarnDetail(row)
		if err == sql.ErrNoRows {
		return nil
	} else if err == nil {
		exists = true
	}
	if err != nil {
		return err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})

	return clusterYarnDetail, exists, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) UpdateClusterYarnDetail(clusterYarnDetailId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("cluster_yarn_detail").Where(goqu.I("id").Eq(clusterYarnDetailId)))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToUpdateSql(q.fields))
	}
	// Execute query
	_, err := q.dataset.Update(q.fields).Exec()
	return errors.Wrap(err, "executing query")
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})

	return errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) DeleteClusterYarnDetail(clusterYarnDetailId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("cluster_yarn_detail").Where(goqu.I("id").Eq(clusterYarnDetailId)))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToDeleteSql())
	}
	// Execute query
	_, err := q.dataset.Delete().Exec()
	return errors.Wrap(err, "executing query")
	})

	return errors.Wrap(err, "committing transaction")
}

func createClusterYarnDetail(tx *goqu.TxDatabase, engineId int64, outputDir string, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("cluster_yarn_detail"))
	// Default insert fields
	clusterYarnDetail := goqu.Record{ 
		"engine_id": engineId, 
		"output_dir": outputDir,
	}
	q.AddFields(clusterYarnDetail)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToInsertSql(q.fields))
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	return res.LastInsertId()
}

func readClusterYarnDetails(tx *goqu.TxDatabase, options ...QueryOpt) ([]ClusterYarnDetail, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("cluster_yarn_detail"))
	for _, option := range options {
		if err := option(q); err != nil {
			return []ClusterYarnDetail{}, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []ClusterYarnDetail{}, err
	}
	
	// Scan rows to ClusterYarnDetails
	return ScanClusterYarnDetails(rows)
}

func readClusterYarnDetail(tx *goqu.TxDatabase, options ...QueryOpt) (ClusterYarnDetail, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("cluster_yarn_detail"))
	for _, option := range options {
		if err := option(q); err != nil {
			return ClusterYarnDetail{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return ClusterYarnDetail{}, false, err
	}
	ret_clusterYarnDetail, err := ScanClusterYarnDetail(row)
	if err == sql.ErrNoRows {
		return ClusterYarnDetail{}, exists, nil
	} else if err == nil {
		exists = true
	}
	// Scan row to ClusterYarnDetail
	return ret_clusterYarnDetail, exists, err
}

func updateClusterYarnDetail(tx *goqu.TxDatabase, clusterYarnDetailId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("cluster_yarn_detail").Where(goqu.I("id").Eq(clusterYarnDetailId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToUpdateSql(q.fields))
	}
	// Execute query
	_, err := q.dataset.Update(q.fields).Exec()
	return errors.Wrap(err, "executing query")
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
}

func deleteClusterYarnDetail(tx *goqu.TxDatabase, clusterYarnDetailId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("cluster_yarn_detail").Where(goqu.I("id").Eq(clusterYarnDetailId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToDeleteSql())
	}
	// Execute query
	_, err := q.dataset.Delete().Exec()
	return errors.Wrap(err, "executing query")
}


// ---------- ------ ----------
// ---------- ------ ----------
// ---------- Engine ----------
// ---------- ------ ----------
// ---------- ------ ----------

func (ds *Datastore) CreateEngine(name, location string, options ...QueryOpt) (int64, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return 0, errors.Wrap(err, "beginning transaction")
	}
	
	var id int64
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("engine"))
		// Default insert fields
	engine := goqu.Record{ 
		"name": name, 
		"location": location,
		"created": time.Now(),
	}
	q.AddFields(engine)
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToInsertSql(q.fields))
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return errors.Wrap(err, "executing query")
	}
	id, err = res.LastInsertId()
	if err != nil {
		return err
	}
	q.result = id
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})

	return id, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadEngines(options ...QueryOpt) ([]Engine, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return []Engine{}, errors.Wrap(err, "beginning transaction")
	}

	var engines []Engine
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("engine"))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToSql())
	}
		// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return err
	}
		engines, err = ScanEngines(rows)
		
	if err != nil {
		return err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})
	
	return engines, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadEngine(options ...QueryOpt) (Engine, bool, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return Engine{}, false, errors.Wrap(err, "beginning transaction")
	}

	var engine Engine
	var exists bool
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("engine"))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToSql())
	}
		// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return err
	}
		engine, err = ScanEngine(row)
		if err == sql.ErrNoRows {
		return nil
	} else if err == nil {
		exists = true
	}
	if err != nil {
		return err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})

	return engine, exists, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) UpdateEngine(engineId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("engine").Where(goqu.I("id").Eq(engineId)))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToUpdateSql(q.fields))
	}
	// Execute query
	_, err := q.dataset.Update(q.fields).Exec()
	return errors.Wrap(err, "executing query")
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})

	return errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) DeleteEngine(engineId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("engine").Where(goqu.I("id").Eq(engineId)))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToDeleteSql())
	}
	// Execute query
	_, err := q.dataset.Delete().Exec()
	return errors.Wrap(err, "executing query")
	})

	return errors.Wrap(err, "committing transaction")
}

func createEngine(tx *goqu.TxDatabase, name, location string, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("engine"))
	// Default insert fields
	engine := goqu.Record{ 
		"name": name, 
		"location": location,
		"created": time.Now(),
	}
	q.AddFields(engine)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToInsertSql(q.fields))
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	return res.LastInsertId()
}

func readEngines(tx *goqu.TxDatabase, options ...QueryOpt) ([]Engine, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("engine"))
	for _, option := range options {
		if err := option(q); err != nil {
			return []Engine{}, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []Engine{}, err
	}
	
	// Scan rows to Engines
	return ScanEngines(rows)
}

func readEngine(tx *goqu.TxDatabase, options ...QueryOpt) (Engine, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("engine"))
	for _, option := range options {
		if err := option(q); err != nil {
			return Engine{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return Engine{}, false, err
	}
	ret_engine, err := ScanEngine(row)
	if err == sql.ErrNoRows {
		return Engine{}, exists, nil
	} else if err == nil {
		exists = true
	}
	// Scan row to Engine
	return ret_engine, exists, err
}

func updateEngine(tx *goqu.TxDatabase, engineId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("engine").Where(goqu.I("id").Eq(engineId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToUpdateSql(q.fields))
	}
	// Execute query
	_, err := q.dataset.Update(q.fields).Exec()
	return errors.Wrap(err, "executing query")
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
}

func deleteEngine(tx *goqu.TxDatabase, engineId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("engine").Where(goqu.I("id").Eq(engineId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToDeleteSql())
	}
	// Execute query
	_, err := q.dataset.Delete().Exec()
	return errors.Wrap(err, "executing query")
}


// ---------- ----------------- ----------
// ---------- ----------------- ----------
// ---------- IdentityWorkgroup ----------
// ---------- ----------------- ----------
// ---------- ----------------- ----------

func (ds *Datastore) CreateIdentityWorkgroup(identityId, workgroupId int64, options ...QueryOpt) (int64, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return 0, errors.Wrap(err, "beginning transaction")
	}
	
	var id int64
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("identity_workgroup"))
		// Default insert fields
	identityWorkgroup := goqu.Record{ 
		"identity_id": identityId, 
		"workgroup_id": workgroupId,
	}
	q.AddFields(identityWorkgroup)
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToInsertSql(q.fields))
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return errors.Wrap(err, "executing query")
	}
	id, err = res.LastInsertId()
	if err != nil {
		return err
	}
	q.result = id
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})

	return id, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadIdentityWorkgroups(options ...QueryOpt) ([]IdentityWorkgroup, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return []IdentityWorkgroup{}, errors.Wrap(err, "beginning transaction")
	}

	var identityWorkgroups []IdentityWorkgroup
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("identity_workgroup"))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToSql())
	}
		// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return err
	}
		identityWorkgroups, err = ScanIdentityWorkgroups(rows)
		
	if err != nil {
		return err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})
	
	return identityWorkgroups, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadIdentityWorkgroup(options ...QueryOpt) (IdentityWorkgroup, bool, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return IdentityWorkgroup{}, false, errors.Wrap(err, "beginning transaction")
	}

	var identityWorkgroup IdentityWorkgroup
	var exists bool
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("identity_workgroup"))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToSql())
	}
		// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return err
	}
		identityWorkgroup, err = ScanIdentityWorkgroup(row)
		if err == sql.ErrNoRows {
		return nil
	} else if err == nil {
		exists = true
	}
	if err != nil {
		return err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})

	return identityWorkgroup, exists, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) UpdateIdentityWorkgroup(identityWorkgroupId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("identity_workgroup"))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToUpdateSql(q.fields))
	}
	// Execute query
	_, err := q.dataset.Update(q.fields).Exec()
	return errors.Wrap(err, "executing query")
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})

	return errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) DeleteIdentityWorkgroup(identityWorkgroupId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("identity_workgroup"))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToDeleteSql())
	}
	// Execute query
	_, err := q.dataset.Delete().Exec()
	return errors.Wrap(err, "executing query")
	})

	return errors.Wrap(err, "committing transaction")
}

func createIdentityWorkgroup(tx *goqu.TxDatabase, identityId, workgroupId int64, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("identity_workgroup"))
	// Default insert fields
	identityWorkgroup := goqu.Record{ 
		"identity_id": identityId, 
		"workgroup_id": workgroupId,
	}
	q.AddFields(identityWorkgroup)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToInsertSql(q.fields))
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	return res.LastInsertId()
}

func readIdentityWorkgroups(tx *goqu.TxDatabase, options ...QueryOpt) ([]IdentityWorkgroup, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("identity_workgroup"))
	for _, option := range options {
		if err := option(q); err != nil {
			return []IdentityWorkgroup{}, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []IdentityWorkgroup{}, err
	}
	
	// Scan rows to IdentityWorkgroups
	return ScanIdentityWorkgroups(rows)
}

func readIdentityWorkgroup(tx *goqu.TxDatabase, options ...QueryOpt) (IdentityWorkgroup, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("identity_workgroup"))
	for _, option := range options {
		if err := option(q); err != nil {
			return IdentityWorkgroup{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return IdentityWorkgroup{}, false, err
	}
	ret_identityWorkgroup, err := ScanIdentityWorkgroup(row)
	if err == sql.ErrNoRows {
		return IdentityWorkgroup{}, exists, nil
	} else if err == nil {
		exists = true
	}
	// Scan row to IdentityWorkgroup
	return ret_identityWorkgroup, exists, err
}

func updateIdentityWorkgroup(tx *goqu.TxDatabase, identityWorkgroupId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("identity_workgroup"))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToUpdateSql(q.fields))
	}
	// Execute query
	_, err := q.dataset.Update(q.fields).Exec()
	return errors.Wrap(err, "executing query")
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
}

func deleteIdentityWorkgroup(tx *goqu.TxDatabase, identityWorkgroupId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("identity_workgroup"))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToDeleteSql())
	}
	// Execute query
	_, err := q.dataset.Delete().Exec()
	return errors.Wrap(err, "executing query")
}


// ---------- ------------- ----------
// ---------- ------------- ----------
// ---------- ModelCategory ----------
// ---------- ------------- ----------
// ---------- ------------- ----------

func (ds *Datastore) CreateModelCategory(name string, options ...QueryOpt) (int64, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return 0, errors.Wrap(err, "beginning transaction")
	}
	
	var id int64
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("model_category"))
		// Default insert fields
	modelCategory := goqu.Record{ 
		"name": name,
	}
	q.AddFields(modelCategory)
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToInsertSql(q.fields))
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return errors.Wrap(err, "executing query")
	}
	id, err = res.LastInsertId()
	if err != nil {
		return err
	}
	q.result = id
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})

	return id, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadModelCategorys(options ...QueryOpt) ([]ModelCategory, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return []ModelCategory{}, errors.Wrap(err, "beginning transaction")
	}

	var modelCategorys []ModelCategory
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("model_category"))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToSql())
	}
		// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return err
	}
		modelCategorys, err = ScanModelCategorys(rows)
		
	if err != nil {
		return err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})
	
	return modelCategorys, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadModelCategory(options ...QueryOpt) (ModelCategory, bool, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return ModelCategory{}, false, errors.Wrap(err, "beginning transaction")
	}

	var modelCategory ModelCategory
	var exists bool
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("model_category"))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToSql())
	}
		// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return err
	}
		modelCategory, err = ScanModelCategory(row)
		if err == sql.ErrNoRows {
		return nil
	} else if err == nil {
		exists = true
	}
	if err != nil {
		return err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})

	return modelCategory, exists, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) UpdateModelCategory(modelCategoryId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("model_category").Where(goqu.I("id").Eq(modelCategoryId)))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToUpdateSql(q.fields))
	}
	// Execute query
	_, err := q.dataset.Update(q.fields).Exec()
	return errors.Wrap(err, "executing query")
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})

	return errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) DeleteModelCategory(modelCategoryId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("model_category").Where(goqu.I("id").Eq(modelCategoryId)))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToDeleteSql())
	}
	// Execute query
	_, err := q.dataset.Delete().Exec()
	return errors.Wrap(err, "executing query")
	})

	return errors.Wrap(err, "committing transaction")
}

func createModelCategory(tx *goqu.TxDatabase, name string, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("model_category"))
	// Default insert fields
	modelCategory := goqu.Record{ 
		"name": name,
	}
	q.AddFields(modelCategory)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToInsertSql(q.fields))
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	return res.LastInsertId()
}

func readModelCategorys(tx *goqu.TxDatabase, options ...QueryOpt) ([]ModelCategory, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("model_category"))
	for _, option := range options {
		if err := option(q); err != nil {
			return []ModelCategory{}, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []ModelCategory{}, err
	}
	
	// Scan rows to ModelCategorys
	return ScanModelCategorys(rows)
}

func readModelCategory(tx *goqu.TxDatabase, options ...QueryOpt) (ModelCategory, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("model_category"))
	for _, option := range options {
		if err := option(q); err != nil {
			return ModelCategory{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return ModelCategory{}, false, err
	}
	ret_modelCategory, err := ScanModelCategory(row)
	if err == sql.ErrNoRows {
		return ModelCategory{}, exists, nil
	} else if err == nil {
		exists = true
	}
	// Scan row to ModelCategory
	return ret_modelCategory, exists, err
}

func updateModelCategory(tx *goqu.TxDatabase, modelCategoryId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("model_category").Where(goqu.I("id").Eq(modelCategoryId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToUpdateSql(q.fields))
	}
	// Execute query
	_, err := q.dataset.Update(q.fields).Exec()
	return errors.Wrap(err, "executing query")
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
}

func deleteModelCategory(tx *goqu.TxDatabase, modelCategoryId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("model_category").Where(goqu.I("id").Eq(modelCategoryId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToDeleteSql())
	}
	// Execute query
	_, err := q.dataset.Delete().Exec()
	return errors.Wrap(err, "executing query")
}


// ---------- ---------- ----------
// ---------- ---------- ----------
// ---------- Permission ----------
// ---------- ---------- ----------
// ---------- ---------- ----------

func (ds *Datastore) CreatePermission(code, description string, options ...QueryOpt) (int64, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return 0, errors.Wrap(err, "beginning transaction")
	}
	
	var id int64
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("permission"))
		// Default insert fields
	permission := goqu.Record{ 
		"code": code, 
		"description": description,
	}
	q.AddFields(permission)
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToInsertSql(q.fields))
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return errors.Wrap(err, "executing query")
	}
	id, err = res.LastInsertId()
	if err != nil {
		return err
	}
	q.result = id
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})

	return id, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadPermissions(options ...QueryOpt) ([]Permission, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return []Permission{}, errors.Wrap(err, "beginning transaction")
	}

	var permissions []Permission
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("permission"))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToSql())
	}
		// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return err
	}
		permissions, err = ScanPermissions(rows)
		
	if err != nil {
		return err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})
	
	return permissions, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadPermission(options ...QueryOpt) (Permission, bool, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return Permission{}, false, errors.Wrap(err, "beginning transaction")
	}

	var permission Permission
	var exists bool
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("permission"))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToSql())
	}
		// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return err
	}
		permission, err = ScanPermission(row)
		if err == sql.ErrNoRows {
		return nil
	} else if err == nil {
		exists = true
	}
	if err != nil {
		return err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})

	return permission, exists, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) UpdatePermission(permissionId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("permission").Where(goqu.I("id").Eq(permissionId)))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToUpdateSql(q.fields))
	}
	// Execute query
	_, err := q.dataset.Update(q.fields).Exec()
	return errors.Wrap(err, "executing query")
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})

	return errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) DeletePermission(permissionId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("permission").Where(goqu.I("id").Eq(permissionId)))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToDeleteSql())
	}
	// Execute query
	_, err := q.dataset.Delete().Exec()
	return errors.Wrap(err, "executing query")
	})

	return errors.Wrap(err, "committing transaction")
}

func createPermission(tx *goqu.TxDatabase, code, description string, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("permission"))
	// Default insert fields
	permission := goqu.Record{ 
		"code": code, 
		"description": description,
	}
	q.AddFields(permission)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToInsertSql(q.fields))
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	return res.LastInsertId()
}

func readPermissions(tx *goqu.TxDatabase, options ...QueryOpt) ([]Permission, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("permission"))
	for _, option := range options {
		if err := option(q); err != nil {
			return []Permission{}, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []Permission{}, err
	}
	
	// Scan rows to Permissions
	return ScanPermissions(rows)
}

func readPermission(tx *goqu.TxDatabase, options ...QueryOpt) (Permission, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("permission"))
	for _, option := range options {
		if err := option(q); err != nil {
			return Permission{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return Permission{}, false, err
	}
	ret_permission, err := ScanPermission(row)
	if err == sql.ErrNoRows {
		return Permission{}, exists, nil
	} else if err == nil {
		exists = true
	}
	// Scan row to Permission
	return ret_permission, exists, err
}

func updatePermission(tx *goqu.TxDatabase, permissionId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("permission").Where(goqu.I("id").Eq(permissionId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToUpdateSql(q.fields))
	}
	// Execute query
	_, err := q.dataset.Update(q.fields).Exec()
	return errors.Wrap(err, "executing query")
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
}

func deletePermission(tx *goqu.TxDatabase, permissionId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("permission").Where(goqu.I("id").Eq(permissionId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToDeleteSql())
	}
	// Execute query
	_, err := q.dataset.Delete().Exec()
	return errors.Wrap(err, "executing query")
}


// ---------- --------- ----------
// ---------- --------- ----------
// ---------- Privilege ----------
// ---------- --------- ----------
// ---------- --------- ----------

func (ds *Datastore) CreatePrivilege(typ string, workgroupId, entityType, entityId int64, options ...QueryOpt) (int64, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return 0, errors.Wrap(err, "beginning transaction")
	}
	
	var id int64
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("privilege"))
		// Default insert fields
	privilege := goqu.Record{ 
		"type": typ, 
		"workgroup_id": workgroupId, 
		"entity_type_id": entityType, 
		"entity_id": entityId,
	}
	q.AddFields(privilege)
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToInsertSql(q.fields))
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return errors.Wrap(err, "executing query")
	}
	id, err = res.LastInsertId()
	if err != nil {
		return err
	}
	q.result = id
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})

	return id, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadPrivileges(options ...QueryOpt) ([]Privilege, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return []Privilege{}, errors.Wrap(err, "beginning transaction")
	}

	var privileges []Privilege
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("privilege"))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToSql())
	}
		// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return err
	}
		privileges, err = ScanPrivileges(rows)
		
	if err != nil {
		return err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})
	
	return privileges, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadPrivilege(options ...QueryOpt) (Privilege, bool, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return Privilege{}, false, errors.Wrap(err, "beginning transaction")
	}

	var privilege Privilege
	var exists bool
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("privilege"))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToSql())
	}
		// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return err
	}
		privilege, err = ScanPrivilege(row)
		if err == sql.ErrNoRows {
		return nil
	} else if err == nil {
		exists = true
	}
	if err != nil {
		return err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})

	return privilege, exists, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) UpdatePrivilege(privilegeId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("privilege").Where(goqu.I("id").Eq(privilegeId)))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToUpdateSql(q.fields))
	}
	// Execute query
	_, err := q.dataset.Update(q.fields).Exec()
	return errors.Wrap(err, "executing query")
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})

	return errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) DeletePrivilege(privilegeId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("privilege").Where(goqu.I("id").Eq(privilegeId)))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToDeleteSql())
	}
	// Execute query
	_, err := q.dataset.Delete().Exec()
	return errors.Wrap(err, "executing query")
	})

	return errors.Wrap(err, "committing transaction")
}

func createPrivilege(tx *goqu.TxDatabase, typ string, workgroupId, entityType, entityId int64, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("privilege"))
	// Default insert fields
	privilege := goqu.Record{ 
		"type": typ, 
		"workgroup_id": workgroupId, 
		"entity_type_id": entityType, 
		"entity_id": entityId,
	}
	q.AddFields(privilege)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToInsertSql(q.fields))
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	return res.LastInsertId()
}

func readPrivileges(tx *goqu.TxDatabase, options ...QueryOpt) ([]Privilege, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("privilege"))
	for _, option := range options {
		if err := option(q); err != nil {
			return []Privilege{}, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []Privilege{}, err
	}
	
	// Scan rows to Privileges
	return ScanPrivileges(rows)
}

func readPrivilege(tx *goqu.TxDatabase, options ...QueryOpt) (Privilege, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("privilege"))
	for _, option := range options {
		if err := option(q); err != nil {
			return Privilege{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return Privilege{}, false, err
	}
	ret_privilege, err := ScanPrivilege(row)
	if err == sql.ErrNoRows {
		return Privilege{}, exists, nil
	} else if err == nil {
		exists = true
	}
	// Scan row to Privilege
	return ret_privilege, exists, err
}

func updatePrivilege(tx *goqu.TxDatabase, privilegeId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("privilege").Where(goqu.I("id").Eq(privilegeId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToUpdateSql(q.fields))
	}
	// Execute query
	_, err := q.dataset.Update(q.fields).Exec()
	return errors.Wrap(err, "executing query")
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
}

func deletePrivilege(tx *goqu.TxDatabase, privilegeId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("privilege").Where(goqu.I("id").Eq(privilegeId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToDeleteSql())
	}
	// Execute query
	_, err := q.dataset.Delete().Exec()
	return errors.Wrap(err, "executing query")
}


// ---------- ------- ----------
// ---------- ------- ----------
// ---------- Project ----------
// ---------- ------- ----------
// ---------- ------- ----------

func (ds *Datastore) CreateProject(name, description, modelCategory string, options ...QueryOpt) (int64, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return 0, errors.Wrap(err, "beginning transaction")
	}
	
	var id int64
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("project"))
		// Default insert fields
	project := goqu.Record{ 
		"name": name, 
		"description": description, 
		"model_category": modelCategory,
		"created": time.Now(),
	}
	q.AddFields(project)
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToInsertSql(q.fields))
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return errors.Wrap(err, "executing query")
	}
	id, err = res.LastInsertId()
	if err != nil {
		return err
	}
	q.result = id
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})

	return id, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadProjects(options ...QueryOpt) ([]Project, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return []Project{}, errors.Wrap(err, "beginning transaction")
	}

	var projects []Project
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("project"))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToSql())
	}
		// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return err
	}
		projects, err = ScanProjects(rows)
		
	if err != nil {
		return err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})
	
	return projects, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadProject(options ...QueryOpt) (Project, bool, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return Project{}, false, errors.Wrap(err, "beginning transaction")
	}

	var project Project
	var exists bool
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("project"))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToSql())
	}
		// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return err
	}
		project, err = ScanProject(row)
		if err == sql.ErrNoRows {
		return nil
	} else if err == nil {
		exists = true
	}
	if err != nil {
		return err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})

	return project, exists, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) UpdateProject(projectId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("project").Where(goqu.I("id").Eq(projectId)))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToUpdateSql(q.fields))
	}
	// Execute query
	_, err := q.dataset.Update(q.fields).Exec()
	return errors.Wrap(err, "executing query")
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})

	return errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) DeleteProject(projectId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("project").Where(goqu.I("id").Eq(projectId)))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToDeleteSql())
	}
	// Execute query
	_, err := q.dataset.Delete().Exec()
	return errors.Wrap(err, "executing query")
	})

	return errors.Wrap(err, "committing transaction")
}

func createProject(tx *goqu.TxDatabase, name, description, modelCategory string, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("project"))
	// Default insert fields
	project := goqu.Record{ 
		"name": name, 
		"description": description, 
		"model_category": modelCategory,
		"created": time.Now(),
	}
	q.AddFields(project)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToInsertSql(q.fields))
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	return res.LastInsertId()
}

func readProjects(tx *goqu.TxDatabase, options ...QueryOpt) ([]Project, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("project"))
	for _, option := range options {
		if err := option(q); err != nil {
			return []Project{}, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []Project{}, err
	}
	
	// Scan rows to Projects
	return ScanProjects(rows)
}

func readProject(tx *goqu.TxDatabase, options ...QueryOpt) (Project, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("project"))
	for _, option := range options {
		if err := option(q); err != nil {
			return Project{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return Project{}, false, err
	}
	ret_project, err := ScanProject(row)
	if err == sql.ErrNoRows {
		return Project{}, exists, nil
	} else if err == nil {
		exists = true
	}
	// Scan row to Project
	return ret_project, exists, err
}

func updateProject(tx *goqu.TxDatabase, projectId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("project").Where(goqu.I("id").Eq(projectId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToUpdateSql(q.fields))
	}
	// Execute query
	_, err := q.dataset.Update(q.fields).Exec()
	return errors.Wrap(err, "executing query")
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
}

func deleteProject(tx *goqu.TxDatabase, projectId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("project").Where(goqu.I("id").Eq(projectId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToDeleteSql())
	}
	// Execute query
	_, err := q.dataset.Delete().Exec()
	return errors.Wrap(err, "executing query")
}


// ---------- ----- ----------
// ---------- ----- ----------
// ---------- State ----------
// ---------- ----- ----------
// ---------- ----- ----------

func (ds *Datastore) CreateState(name string, options ...QueryOpt) (int64, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return 0, errors.Wrap(err, "beginning transaction")
	}
	
	var id int64
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("state"))
		// Default insert fields
	state := goqu.Record{ 
		"name": name,
	}
	q.AddFields(state)
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToInsertSql(q.fields))
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return errors.Wrap(err, "executing query")
	}
	id, err = res.LastInsertId()
	if err != nil {
		return err
	}
	q.result = id
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})

	return id, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadStates(options ...QueryOpt) ([]State, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return []State{}, errors.Wrap(err, "beginning transaction")
	}

	var states []State
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("state"))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToSql())
	}
		// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return err
	}
		states, err = ScanStates(rows)
		
	if err != nil {
		return err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})
	
	return states, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadState(options ...QueryOpt) (State, bool, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return State{}, false, errors.Wrap(err, "beginning transaction")
	}

	var state State
	var exists bool
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("state"))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToSql())
	}
		// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return err
	}
		state, err = ScanState(row)
		if err == sql.ErrNoRows {
		return nil
	} else if err == nil {
		exists = true
	}
	if err != nil {
		return err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})

	return state, exists, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) UpdateState(stateId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("state").Where(goqu.I("id").Eq(stateId)))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToUpdateSql(q.fields))
	}
	// Execute query
	_, err := q.dataset.Update(q.fields).Exec()
	return errors.Wrap(err, "executing query")
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})

	return errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) DeleteState(stateId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("state").Where(goqu.I("id").Eq(stateId)))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToDeleteSql())
	}
	// Execute query
	_, err := q.dataset.Delete().Exec()
	return errors.Wrap(err, "executing query")
	})

	return errors.Wrap(err, "committing transaction")
}

func createState(tx *goqu.TxDatabase, name string, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("state"))
	// Default insert fields
	state := goqu.Record{ 
		"name": name,
	}
	q.AddFields(state)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToInsertSql(q.fields))
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	return res.LastInsertId()
}

func readStates(tx *goqu.TxDatabase, options ...QueryOpt) ([]State, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("state"))
	for _, option := range options {
		if err := option(q); err != nil {
			return []State{}, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []State{}, err
	}
	
	// Scan rows to States
	return ScanStates(rows)
}

func readState(tx *goqu.TxDatabase, options ...QueryOpt) (State, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("state"))
	for _, option := range options {
		if err := option(q); err != nil {
			return State{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return State{}, false, err
	}
	ret_state, err := ScanState(row)
	if err == sql.ErrNoRows {
		return State{}, exists, nil
	} else if err == nil {
		exists = true
	}
	// Scan row to State
	return ret_state, exists, err
}

func updateState(tx *goqu.TxDatabase, stateId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("state").Where(goqu.I("id").Eq(stateId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToUpdateSql(q.fields))
	}
	// Execute query
	_, err := q.dataset.Update(q.fields).Exec()
	return errors.Wrap(err, "executing query")
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
}

func deleteState(tx *goqu.TxDatabase, stateId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("state").Where(goqu.I("id").Eq(stateId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToDeleteSql())
	}
	// Execute query
	_, err := q.dataset.Delete().Exec()
	return errors.Wrap(err, "executing query")
}


// ---------- ------- ----------
// ---------- ------- ----------
// ---------- Service ----------
// ---------- ------- ----------
// ---------- ------- ----------

func (ds *Datastore) CreateService(projectId, modelId int64, name string, options ...QueryOpt) (int64, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return 0, errors.Wrap(err, "beginning transaction")
	}
	
	var id int64
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("service"))
		// Default insert fields
	service := goqu.Record{ 
		"project_id": projectId, 
		"model_id": modelId, 
		"name": name,
		"state": q.state.Starting,
		"created": time.Now(),
	}
	q.AddFields(service)
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToInsertSql(q.fields))
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return errors.Wrap(err, "executing query")
	}
	id, err = res.LastInsertId()
	if err != nil {
		return err
	}
	q.result = id
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})

	return id, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadServices(options ...QueryOpt) ([]Service, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return []Service{}, errors.Wrap(err, "beginning transaction")
	}

	var services []Service
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("service"))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToSql())
	}
		// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return err
	}
		services, err = ScanServices(rows)
		
	if err != nil {
		return err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})
	
	return services, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadService(options ...QueryOpt) (Service, bool, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return Service{}, false, errors.Wrap(err, "beginning transaction")
	}

	var service Service
	var exists bool
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("service"))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToSql())
	}
		// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return err
	}
		service, err = ScanService(row)
		if err == sql.ErrNoRows {
		return nil
	} else if err == nil {
		exists = true
	}
	if err != nil {
		return err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})

	return service, exists, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) UpdateService(serviceId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("service").Where(goqu.I("id").Eq(serviceId)))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToUpdateSql(q.fields))
	}
	// Execute query
	_, err := q.dataset.Update(q.fields).Exec()
	return errors.Wrap(err, "executing query")
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
	})

	return errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) DeleteService(serviceId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, tx.From("service").Where(goqu.I("id").Eq(serviceId)))
		for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
		if DEBUG {
		log.Println(q.dataset.ToDeleteSql())
	}
	// Execute query
	_, err := q.dataset.Delete().Exec()
	return errors.Wrap(err, "executing query")
	})

	return errors.Wrap(err, "committing transaction")
}

func createService(tx *goqu.TxDatabase, projectId, modelId int64, name string, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("service"))
	// Default insert fields
	service := goqu.Record{ 
		"project_id": projectId, 
		"model_id": modelId, 
		"name": name,
		"state": q.state.Starting,
		"created": time.Now(),
	}
	q.AddFields(service)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToInsertSql(q.fields))
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	return res.LastInsertId()
}

func readServices(tx *goqu.TxDatabase, options ...QueryOpt) ([]Service, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("service"))
	for _, option := range options {
		if err := option(q); err != nil {
			return []Service{}, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []Service{}, err
	}
	
	// Scan rows to Services
	return ScanServices(rows)
}

func readService(tx *goqu.TxDatabase, options ...QueryOpt) (Service, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("service"))
	for _, option := range options {
		if err := option(q); err != nil {
			return Service{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return Service{}, false, err
	}
	ret_service, err := ScanService(row)
	if err == sql.ErrNoRows {
		return Service{}, exists, nil
	} else if err == nil {
		exists = true
	}
	// Scan row to Service
	return ret_service, exists, err
}

func updateService(tx *goqu.TxDatabase, serviceId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("service").Where(goqu.I("id").Eq(serviceId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToUpdateSql(q.fields))
	}
	// Execute query
	_, err := q.dataset.Update(q.fields).Exec()
	return errors.Wrap(err, "executing query")
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil
}

func deleteService(tx *goqu.TxDatabase, serviceId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, tx.From("service").Where(goqu.I("id").Eq(serviceId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToDeleteSql())
	}
	// Execute query
	_, err := q.dataset.Delete().Exec()
	return errors.Wrap(err, "executing query")
}


