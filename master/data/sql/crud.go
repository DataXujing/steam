// GENERATED BY crudgen; DON'T EDIT

package sql

import (
	"database/sql"
	"encoding/json"
	"log"
	"time"

	"github.com/pkg/errors"
	"gopkg.in/doug-martin/goqu.v3"
)

var DEBUG bool

// ---------- ------- ----------
// ---------- ------- ----------
// ---------- Cluster ----------
// ---------- ------- ----------
// ---------- ------- ----------

func (ds *Datastore) CreateCluster(name string, clusterTypeId int64, options ...QueryOpt) (int64, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return 0, errors.Wrap(err, "beginning transaction")
	}

	var id int64
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "cluster", tx.From("cluster"))
		// Default insert fields
		cluster := goqu.Record{
			"name":    name,
			"type_id": clusterTypeId,
			"state":   q.state.Starting,
			"created": time.Now(),
		}
		q.AddFields(cluster)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToInsertSql(q.fields))
		}
		// Execute query
		res, err := q.dataset.Insert(q.fields).Exec()
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		id, err = res.LastInsertId()
		q.result = id
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		// Create audit for entity
		if q.audit {
			json, err := json.Marshal(q.fields)
			if err != nil {
				return errors.Wrap(err, "serializing metadata")
			}
			_, err = createHistory(q.tx, CreateOp, q.pz.Id(), q.entityType.Cluster, id,
				WithDescription(string(json)),
			)
			return errors.Wrap(err, "creating audit entry")
		}

		return nil
	})

	return id, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadClusters(options ...QueryOpt) ([]Cluster, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return []Cluster{}, errors.Wrap(err, "beginning transaction")
	}

	var clusters []Cluster
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "cluster", tx.From("cluster"))
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToSql())
		}
		// Execute query
		rows, err := getRows(tx, q.dataset)
		if err != nil {
			return err
		}
		defer rows.Close()
		clusters, err = ScanClusters(rows)

		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return clusters, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadCluster(options ...QueryOpt) (Cluster, bool, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return Cluster{}, false, errors.Wrap(err, "beginning transaction")
	}

	var cluster Cluster
	var exists bool
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "cluster", tx.From("cluster"))
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToSql())
		}
		// Execute query
		row, err := getRow(tx, q.dataset)
		if err != nil {
			return err
		}
		cluster, err = ScanCluster(row)
		if err == sql.ErrNoRows {
			return nil
		} else if err == nil {
			exists = true
		}
		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return cluster, exists, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) UpdateCluster(clusterId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "cluster", tx.From("cluster").Where(goqu.I("id").Eq(clusterId)))
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToUpdateSql(q.fields))
		}
		// Execute query
		_, err := q.dataset.Update(q.fields).Exec()
		return errors.Wrap(err, "executing query")
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}
		if q.audit {
			json, err := json.Marshal(q.fields)
			if err != nil {
				return errors.Wrap(err, "serializing metadata")
			}
			_, err = createHistory(q.tx, UpdateOp, q.pz.Id(), q.entityType.Cluster, clusterId,
				WithDescription(string(json)),
			)
			return errors.Wrap(err, "creating audit entry")
		}
		return nil
	})

	return errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) DeleteCluster(clusterId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "cluster", tx.From("cluster").Where(goqu.I("id").Eq(clusterId)))
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToDeleteSql())
		}
		// Execute query
		_, err := q.dataset.Delete().Exec()
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		if q.audit {
			json, err := json.Marshal(q.fields)
			if err != nil {
				return errors.Wrap(err, "serializing metadata")
			}
			_, err = createHistory(q.tx, DeleteOp, q.pz.Id(), q.entityType.Cluster, clusterId,
				WithDescription(string(json)),
			)
			return errors.Wrap(err, "creating audit entry")
		}
		return nil
	})

	return errors.Wrap(err, "committing transaction")
}
func createCluster(tx *goqu.TxDatabase, name string, clusterTypeId int64, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "cluster", tx.From("cluster"))
	// Default insert fields
	cluster := goqu.Record{
		"name":    name,
		"type_id": clusterTypeId,
		"state":   q.state.Starting,
		"created": time.Now(),
	}
	q.AddFields(cluster)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToInsertSql(q.fields))
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	return res.LastInsertId()
}

func readClusters(tx *goqu.TxDatabase, options ...QueryOpt) ([]Cluster, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "cluster", tx.From("cluster"))
	for _, option := range options {
		if err := option(q); err != nil {
			return []Cluster{}, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []Cluster{}, err
	}
	defer rows.Close()

	// Scan rows to Clusters
	return ScanClusters(rows)
}

func readCluster(tx *goqu.TxDatabase, options ...QueryOpt) (Cluster, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "cluster", tx.From("cluster"))
	for _, option := range options {
		if err := option(q); err != nil {
			return Cluster{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return Cluster{}, false, err
	}
	ret_cluster, err := ScanCluster(row)
	if err == sql.ErrNoRows {
		return Cluster{}, exists, nil
	} else if err == nil {
		exists = true
	}
	// Scan row to Cluster
	return ret_cluster, exists, err
}

func updateCluster(tx *goqu.TxDatabase, clusterId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "cluster", tx.From("cluster").Where(goqu.I("id").Eq(clusterId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToUpdateSql(q.fields))
	}
	// Execute query
	_, err := q.dataset.Update(q.fields).Exec()
	return errors.Wrap(err, "executing query")
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deleteCluster(tx *goqu.TxDatabase, clusterId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "cluster", tx.From("cluster").Where(goqu.I("id").Eq(clusterId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToDeleteSql())
	}
	// Execute query
	_, err := q.dataset.Delete().Exec()
	return errors.Wrap(err, "executing query")
}

// ---------- ----------- ----------
// ---------- ----------- ----------
// ---------- clusterType ----------
// ---------- ----------- ----------
// ---------- ----------- ----------

func createClusterType(tx *goqu.TxDatabase, name string, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "cluster_type", tx.From("cluster_type"))
	// Default insert fields
	clusterType := goqu.Record{
		"name": name,
	}
	q.AddFields(clusterType)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToInsertSql(q.fields))
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	return res.LastInsertId()
}

func readClusterTypes(tx *goqu.TxDatabase, options ...QueryOpt) ([]clusterType, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "cluster_type", tx.From("cluster_type"))
	for _, option := range options {
		if err := option(q); err != nil {
			return []clusterType{}, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []clusterType{}, err
	}
	defer rows.Close()

	// Scan rows to clusterTypes
	return ScanClusterTypes(rows)
}

func readClusterType(tx *goqu.TxDatabase, options ...QueryOpt) (clusterType, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "cluster_type", tx.From("cluster_type"))
	for _, option := range options {
		if err := option(q); err != nil {
			return clusterType{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return clusterType{}, false, err
	}
	ret_clusterType, err := ScanClusterType(row)
	if err == sql.ErrNoRows {
		return clusterType{}, exists, nil
	} else if err == nil {
		exists = true
	}
	// Scan row to clusterType
	return ret_clusterType, exists, err
}

func updateClusterType(tx *goqu.TxDatabase, clusterTypeId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "cluster_type", tx.From("cluster_type").Where(goqu.I("id").Eq(clusterTypeId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToUpdateSql(q.fields))
	}
	// Execute query
	_, err := q.dataset.Update(q.fields).Exec()
	return errors.Wrap(err, "executing query")
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deleteClusterType(tx *goqu.TxDatabase, clusterTypeId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "cluster_type", tx.From("cluster_type").Where(goqu.I("id").Eq(clusterTypeId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToDeleteSql())
	}
	// Execute query
	_, err := q.dataset.Delete().Exec()
	return errors.Wrap(err, "executing query")
}

// ---------- ----------------- ----------
// ---------- ----------------- ----------
// ---------- ClusterYarnDetail ----------
// ---------- ----------------- ----------
// ---------- ----------------- ----------

func (ds *Datastore) CreateClusterYarnDetail(engineId, size int64, applicationId, memory, outputDir string, options ...QueryOpt) (int64, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return 0, errors.Wrap(err, "beginning transaction")
	}

	var id int64
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "cluster_yarn_detail", tx.From("cluster_yarn_detail"))
		// Default insert fields
		clusterYarnDetail := goqu.Record{
			"engine_id":      engineId,
			"size":           size,
			"application_id": applicationId,
			"memory":         memory,
			"output_dir":     outputDir,
		}
		q.AddFields(clusterYarnDetail)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToInsertSql(q.fields))
		}
		// Execute query
		res, err := q.dataset.Insert(q.fields).Exec()
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		id, err = res.LastInsertId()
		q.result = id
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		// Create audit for entity
		if q.audit {
			json, err := json.Marshal(q.fields)
			if err != nil {
				return errors.Wrap(err, "serializing metadata")
			}
			_, err = createHistory(q.tx, CreateOp, q.pz.Id(), q.entityType.ClusterYarnDetail, id,
				WithDescription(string(json)),
			)
			return errors.Wrap(err, "creating audit entry")
		}

		return nil
	})

	return id, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadClusterYarnDetails(options ...QueryOpt) ([]ClusterYarnDetail, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return []ClusterYarnDetail{}, errors.Wrap(err, "beginning transaction")
	}

	var clusterYarnDetails []ClusterYarnDetail
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "cluster_yarn_detail", tx.From("cluster_yarn_detail"))
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToSql())
		}
		// Execute query
		rows, err := getRows(tx, q.dataset)
		if err != nil {
			return err
		}
		defer rows.Close()
		clusterYarnDetails, err = ScanClusterYarnDetails(rows)

		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return clusterYarnDetails, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadClusterYarnDetail(options ...QueryOpt) (ClusterYarnDetail, bool, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return ClusterYarnDetail{}, false, errors.Wrap(err, "beginning transaction")
	}

	var clusterYarnDetail ClusterYarnDetail
	var exists bool
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "cluster_yarn_detail", tx.From("cluster_yarn_detail"))
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToSql())
		}
		// Execute query
		row, err := getRow(tx, q.dataset)
		if err != nil {
			return err
		}
		clusterYarnDetail, err = ScanClusterYarnDetail(row)
		if err == sql.ErrNoRows {
			return nil
		} else if err == nil {
			exists = true
		}
		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return clusterYarnDetail, exists, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) UpdateClusterYarnDetail(clusterYarnDetailId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "cluster_yarn_detail", tx.From("cluster_yarn_detail").Where(goqu.I("id").Eq(clusterYarnDetailId)))
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToUpdateSql(q.fields))
		}
		// Execute query
		_, err := q.dataset.Update(q.fields).Exec()
		return errors.Wrap(err, "executing query")
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}
		if q.audit {
			json, err := json.Marshal(q.fields)
			if err != nil {
				return errors.Wrap(err, "serializing metadata")
			}
			_, err = createHistory(q.tx, UpdateOp, q.pz.Id(), q.entityType.ClusterYarnDetail, clusterYarnDetailId,
				WithDescription(string(json)),
			)
			return errors.Wrap(err, "creating audit entry")
		}
		return nil
	})

	return errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) DeleteClusterYarnDetail(clusterYarnDetailId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "cluster_yarn_detail", tx.From("cluster_yarn_detail").Where(goqu.I("id").Eq(clusterYarnDetailId)))
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToDeleteSql())
		}
		// Execute query
		_, err := q.dataset.Delete().Exec()
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		if q.audit {
			json, err := json.Marshal(q.fields)
			if err != nil {
				return errors.Wrap(err, "serializing metadata")
			}
			_, err = createHistory(q.tx, DeleteOp, q.pz.Id(), q.entityType.ClusterYarnDetail, clusterYarnDetailId,
				WithDescription(string(json)),
			)
			return errors.Wrap(err, "creating audit entry")
		}
		return nil
	})

	return errors.Wrap(err, "committing transaction")
}
func createClusterYarnDetail(tx *goqu.TxDatabase, engineId, size int64, applicationId, memory, outputDir string, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "cluster_yarn_detail", tx.From("cluster_yarn_detail"))
	// Default insert fields
	clusterYarnDetail := goqu.Record{
		"engine_id":      engineId,
		"size":           size,
		"application_id": applicationId,
		"memory":         memory,
		"output_dir":     outputDir,
	}
	q.AddFields(clusterYarnDetail)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToInsertSql(q.fields))
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	return res.LastInsertId()
}

func readClusterYarnDetails(tx *goqu.TxDatabase, options ...QueryOpt) ([]ClusterYarnDetail, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "cluster_yarn_detail", tx.From("cluster_yarn_detail"))
	for _, option := range options {
		if err := option(q); err != nil {
			return []ClusterYarnDetail{}, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []ClusterYarnDetail{}, err
	}
	defer rows.Close()

	// Scan rows to ClusterYarnDetails
	return ScanClusterYarnDetails(rows)
}

func readClusterYarnDetail(tx *goqu.TxDatabase, options ...QueryOpt) (ClusterYarnDetail, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "cluster_yarn_detail", tx.From("cluster_yarn_detail"))
	for _, option := range options {
		if err := option(q); err != nil {
			return ClusterYarnDetail{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return ClusterYarnDetail{}, false, err
	}
	ret_clusterYarnDetail, err := ScanClusterYarnDetail(row)
	if err == sql.ErrNoRows {
		return ClusterYarnDetail{}, exists, nil
	} else if err == nil {
		exists = true
	}
	// Scan row to ClusterYarnDetail
	return ret_clusterYarnDetail, exists, err
}

func updateClusterYarnDetail(tx *goqu.TxDatabase, clusterYarnDetailId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "cluster_yarn_detail", tx.From("cluster_yarn_detail").Where(goqu.I("id").Eq(clusterYarnDetailId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToUpdateSql(q.fields))
	}
	// Execute query
	_, err := q.dataset.Update(q.fields).Exec()
	return errors.Wrap(err, "executing query")
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deleteClusterYarnDetail(tx *goqu.TxDatabase, clusterYarnDetailId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "cluster_yarn_detail", tx.From("cluster_yarn_detail").Where(goqu.I("id").Eq(clusterYarnDetailId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToDeleteSql())
	}
	// Execute query
	_, err := q.dataset.Delete().Exec()
	return errors.Wrap(err, "executing query")
}

// ---------- ------ ----------
// ---------- ------ ----------
// ---------- Engine ----------
// ---------- ------ ----------
// ---------- ------ ----------

func (ds *Datastore) CreateEngine(name, location string, options ...QueryOpt) (int64, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return 0, errors.Wrap(err, "beginning transaction")
	}

	var id int64
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "engine", tx.From("engine"))
		// Default insert fields
		engine := goqu.Record{
			"name":     name,
			"location": location,
			"created":  time.Now(),
		}
		q.AddFields(engine)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToInsertSql(q.fields))
		}
		// Execute query
		res, err := q.dataset.Insert(q.fields).Exec()
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		id, err = res.LastInsertId()
		q.result = id
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		// Create audit for entity
		if q.audit {
			json, err := json.Marshal(q.fields)
			if err != nil {
				return errors.Wrap(err, "serializing metadata")
			}
			_, err = createHistory(q.tx, CreateOp, q.pz.Id(), q.entityType.Engine, id,
				WithDescription(string(json)),
			)
			return errors.Wrap(err, "creating audit entry")
		}

		return nil
	})

	return id, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadEngines(options ...QueryOpt) ([]Engine, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return []Engine{}, errors.Wrap(err, "beginning transaction")
	}

	var engines []Engine
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "engine", tx.From("engine"))
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToSql())
		}
		// Execute query
		rows, err := getRows(tx, q.dataset)
		if err != nil {
			return err
		}
		defer rows.Close()
		engines, err = ScanEngines(rows)

		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return engines, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadEngine(options ...QueryOpt) (Engine, bool, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return Engine{}, false, errors.Wrap(err, "beginning transaction")
	}

	var engine Engine
	var exists bool
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "engine", tx.From("engine"))
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToSql())
		}
		// Execute query
		row, err := getRow(tx, q.dataset)
		if err != nil {
			return err
		}
		engine, err = ScanEngine(row)
		if err == sql.ErrNoRows {
			return nil
		} else if err == nil {
			exists = true
		}
		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return engine, exists, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) UpdateEngine(engineId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "engine", tx.From("engine").Where(goqu.I("id").Eq(engineId)))
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToUpdateSql(q.fields))
		}
		// Execute query
		_, err := q.dataset.Update(q.fields).Exec()
		return errors.Wrap(err, "executing query")
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}
		if q.audit {
			json, err := json.Marshal(q.fields)
			if err != nil {
				return errors.Wrap(err, "serializing metadata")
			}
			_, err = createHistory(q.tx, UpdateOp, q.pz.Id(), q.entityType.Engine, engineId,
				WithDescription(string(json)),
			)
			return errors.Wrap(err, "creating audit entry")
		}
		return nil
	})

	return errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) DeleteEngine(engineId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "engine", tx.From("engine").Where(goqu.I("id").Eq(engineId)))
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToDeleteSql())
		}
		// Execute query
		_, err := q.dataset.Delete().Exec()
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		if q.audit {
			json, err := json.Marshal(q.fields)
			if err != nil {
				return errors.Wrap(err, "serializing metadata")
			}
			_, err = createHistory(q.tx, DeleteOp, q.pz.Id(), q.entityType.Engine, engineId,
				WithDescription(string(json)),
			)
			return errors.Wrap(err, "creating audit entry")
		}
		return nil
	})

	return errors.Wrap(err, "committing transaction")
}
func createEngine(tx *goqu.TxDatabase, name, location string, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "engine", tx.From("engine"))
	// Default insert fields
	engine := goqu.Record{
		"name":     name,
		"location": location,
		"created":  time.Now(),
	}
	q.AddFields(engine)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToInsertSql(q.fields))
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	return res.LastInsertId()
}

func readEngines(tx *goqu.TxDatabase, options ...QueryOpt) ([]Engine, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "engine", tx.From("engine"))
	for _, option := range options {
		if err := option(q); err != nil {
			return []Engine{}, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []Engine{}, err
	}
	defer rows.Close()

	// Scan rows to Engines
	return ScanEngines(rows)
}

func readEngine(tx *goqu.TxDatabase, options ...QueryOpt) (Engine, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "engine", tx.From("engine"))
	for _, option := range options {
		if err := option(q); err != nil {
			return Engine{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return Engine{}, false, err
	}
	ret_engine, err := ScanEngine(row)
	if err == sql.ErrNoRows {
		return Engine{}, exists, nil
	} else if err == nil {
		exists = true
	}
	// Scan row to Engine
	return ret_engine, exists, err
}

func updateEngine(tx *goqu.TxDatabase, engineId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "engine", tx.From("engine").Where(goqu.I("id").Eq(engineId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToUpdateSql(q.fields))
	}
	// Execute query
	_, err := q.dataset.Update(q.fields).Exec()
	return errors.Wrap(err, "executing query")
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deleteEngine(tx *goqu.TxDatabase, engineId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "engine", tx.From("engine").Where(goqu.I("id").Eq(engineId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToDeleteSql())
	}
	// Execute query
	_, err := q.dataset.Delete().Exec()
	return errors.Wrap(err, "executing query")
}

// ---------- ---------- ----------
// ---------- ---------- ----------
// ---------- entityType ----------
// ---------- ---------- ----------
// ---------- ---------- ----------

func createEntityType(tx *goqu.TxDatabase, name string, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "entity_type", tx.From("entity_type"))
	// Default insert fields
	entityType := goqu.Record{
		"name": name,
	}
	q.AddFields(entityType)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToInsertSql(q.fields))
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	return res.LastInsertId()
}

func readEntityTypes(tx *goqu.TxDatabase, options ...QueryOpt) ([]entityType, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "entity_type", tx.From("entity_type"))
	for _, option := range options {
		if err := option(q); err != nil {
			return []entityType{}, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []entityType{}, err
	}
	defer rows.Close()

	// Scan rows to entityTypes
	return ScanEntityTypes(rows)
}

func readEntityType(tx *goqu.TxDatabase, options ...QueryOpt) (entityType, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "entity_type", tx.From("entity_type"))
	for _, option := range options {
		if err := option(q); err != nil {
			return entityType{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return entityType{}, false, err
	}
	ret_entityType, err := ScanEntityType(row)
	if err == sql.ErrNoRows {
		return entityType{}, exists, nil
	} else if err == nil {
		exists = true
	}
	// Scan row to entityType
	return ret_entityType, exists, err
}

func updateEntityType(tx *goqu.TxDatabase, entityTypeId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "entity_type", tx.From("entity_type").Where(goqu.I("id").Eq(entityTypeId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToUpdateSql(q.fields))
	}
	// Execute query
	_, err := q.dataset.Update(q.fields).Exec()
	return errors.Wrap(err, "executing query")
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deleteEntityType(tx *goqu.TxDatabase, entityTypeId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "entity_type", tx.From("entity_type").Where(goqu.I("id").Eq(entityTypeId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToDeleteSql())
	}
	// Execute query
	_, err := q.dataset.Delete().Exec()
	return errors.Wrap(err, "executing query")
}

// ---------- ------- ----------
// ---------- ------- ----------
// ---------- history ----------
// ---------- ------- ----------
// ---------- ------- ----------

func createHistory(tx *goqu.TxDatabase, action string, identityId, entityTypeId, entityId int64, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "history", tx.From("history"))
	// Default insert fields
	history := goqu.Record{
		"action":         action,
		"identity_id":    identityId,
		"entity_type_id": entityTypeId,
		"entity_id":      entityId,
		"created":        time.Now(),
	}
	q.AddFields(history)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToInsertSql(q.fields))
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	return res.LastInsertId()
}

func readHistories(tx *goqu.TxDatabase, options ...QueryOpt) ([]history, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "history", tx.From("history"))
	for _, option := range options {
		if err := option(q); err != nil {
			return []history{}, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []history{}, err
	}
	defer rows.Close()

	// Scan rows to histories
	return ScanHistorys(rows)
}

func readHistory(tx *goqu.TxDatabase, options ...QueryOpt) (history, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "history", tx.From("history"))
	for _, option := range options {
		if err := option(q); err != nil {
			return history{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return history{}, false, err
	}
	ret_history, err := ScanHistory(row)
	if err == sql.ErrNoRows {
		return history{}, exists, nil
	} else if err == nil {
		exists = true
	}
	// Scan row to history
	return ret_history, exists, err
}

func updateHistory(tx *goqu.TxDatabase, historyId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "history", tx.From("history").Where(goqu.I("id").Eq(historyId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToUpdateSql(q.fields))
	}
	// Execute query
	_, err := q.dataset.Update(q.fields).Exec()
	return errors.Wrap(err, "executing query")
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deleteHistory(tx *goqu.TxDatabase, historyId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "history", tx.From("history").Where(goqu.I("id").Eq(historyId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToDeleteSql())
	}
	// Execute query
	_, err := q.dataset.Delete().Exec()
	return errors.Wrap(err, "executing query")
}

// ---------- -------- ----------
// ---------- -------- ----------
// ---------- Identity ----------
// ---------- -------- ----------
// ---------- -------- ----------

func (ds *Datastore) CreateIdentity(name string, options ...QueryOpt) (int64, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return 0, errors.Wrap(err, "beginning transaction")
	}

	var id int64
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "identity", tx.From("identity"))
		// Default insert fields
		identity := goqu.Record{
			"name":      name,
			"is_active": 1,
			"created":   time.Now(),
		}
		q.AddFields(identity)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToInsertSql(q.fields))
		}
		// Execute query
		res, err := q.dataset.Insert(q.fields).Exec()
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		id, err = res.LastInsertId()
		q.result = id
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		// Create audit for entity
		if q.audit {
			json, err := json.Marshal(q.fields)
			if err != nil {
				return errors.Wrap(err, "serializing metadata")
			}
			_, err = createHistory(q.tx, CreateOp, q.pz.Id(), q.entityType.Identity, id,
				WithDescription(string(json)),
			)
			return errors.Wrap(err, "creating audit entry")
		}

		return nil
	})

	return id, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadIdentities(options ...QueryOpt) ([]Identity, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return []Identity{}, errors.Wrap(err, "beginning transaction")
	}

	var identities []Identity
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "identity", tx.From("identity"))
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToSql())
		}
		// Execute query
		rows, err := getRows(tx, q.dataset)
		if err != nil {
			return err
		}
		defer rows.Close()
		identities, err = ScanIdentitys(rows)

		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return identities, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadIdentity(options ...QueryOpt) (Identity, bool, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return Identity{}, false, errors.Wrap(err, "beginning transaction")
	}

	var identity Identity
	var exists bool
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "identity", tx.From("identity"))
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToSql())
		}
		// Execute query
		row, err := getRow(tx, q.dataset)
		if err != nil {
			return err
		}
		identity, err = ScanIdentity(row)
		if err == sql.ErrNoRows {
			return nil
		} else if err == nil {
			exists = true
		}
		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return identity, exists, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) UpdateIdentity(identityId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "identity", tx.From("identity").Where(goqu.I("id").Eq(identityId)))
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToUpdateSql(q.fields))
		}
		// Execute query
		_, err := q.dataset.Update(q.fields).Exec()
		return errors.Wrap(err, "executing query")
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}
		if q.audit {
			json, err := json.Marshal(q.fields)
			if err != nil {
				return errors.Wrap(err, "serializing metadata")
			}
			_, err = createHistory(q.tx, UpdateOp, q.pz.Id(), q.entityType.Identity, identityId,
				WithDescription(string(json)),
			)
			return errors.Wrap(err, "creating audit entry")
		}
		return nil
	})

	return errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) DeleteIdentity(identityId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "identity", tx.From("identity").Where(goqu.I("id").Eq(identityId)))
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToDeleteSql())
		}
		// Execute query
		_, err := q.dataset.Delete().Exec()
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		if q.audit {
			json, err := json.Marshal(q.fields)
			if err != nil {
				return errors.Wrap(err, "serializing metadata")
			}
			_, err = createHistory(q.tx, DeleteOp, q.pz.Id(), q.entityType.Identity, identityId,
				WithDescription(string(json)),
			)
			return errors.Wrap(err, "creating audit entry")
		}
		return nil
	})

	return errors.Wrap(err, "committing transaction")
}
func createIdentity(tx *goqu.TxDatabase, name string, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "identity", tx.From("identity"))
	// Default insert fields
	identity := goqu.Record{
		"name":      name,
		"is_active": 1,
		"created":   time.Now(),
	}
	q.AddFields(identity)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToInsertSql(q.fields))
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	return res.LastInsertId()
}

func readIdentities(tx *goqu.TxDatabase, options ...QueryOpt) ([]Identity, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "identity", tx.From("identity"))
	for _, option := range options {
		if err := option(q); err != nil {
			return []Identity{}, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []Identity{}, err
	}
	defer rows.Close()

	// Scan rows to Identities
	return ScanIdentitys(rows)
}

func readIdentity(tx *goqu.TxDatabase, options ...QueryOpt) (Identity, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "identity", tx.From("identity"))
	for _, option := range options {
		if err := option(q); err != nil {
			return Identity{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return Identity{}, false, err
	}
	ret_identity, err := ScanIdentity(row)
	if err == sql.ErrNoRows {
		return Identity{}, exists, nil
	} else if err == nil {
		exists = true
	}
	// Scan row to Identity
	return ret_identity, exists, err
}

func updateIdentity(tx *goqu.TxDatabase, identityId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "identity", tx.From("identity").Where(goqu.I("id").Eq(identityId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToUpdateSql(q.fields))
	}
	// Execute query
	_, err := q.dataset.Update(q.fields).Exec()
	return errors.Wrap(err, "executing query")
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deleteIdentity(tx *goqu.TxDatabase, identityId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "identity", tx.From("identity").Where(goqu.I("id").Eq(identityId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToDeleteSql())
	}
	// Execute query
	_, err := q.dataset.Delete().Exec()
	return errors.Wrap(err, "executing query")
}

// ---------- ------------ ----------
// ---------- ------------ ----------
// ---------- identityRole ----------
// ---------- ------------ ----------
// ---------- ------------ ----------

func createIdentityRole(tx *goqu.TxDatabase, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "identity_role", tx.From("identity_role"))
	// Default insert fields
	identityRole := goqu.Record{}
	q.AddFields(identityRole)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToInsertSql(q.fields))
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	return res.LastInsertId()
}

func readIdentityRoles(tx *goqu.TxDatabase, options ...QueryOpt) ([]identityRole, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "identity_role", tx.From("identity_role"))
	for _, option := range options {
		if err := option(q); err != nil {
			return []identityRole{}, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []identityRole{}, err
	}
	defer rows.Close()

	// Scan rows to identityRoles
	return ScanIdentityRoles(rows)
}

func readIdentityRole(tx *goqu.TxDatabase, options ...QueryOpt) (identityRole, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "identity_role", tx.From("identity_role"))
	for _, option := range options {
		if err := option(q); err != nil {
			return identityRole{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return identityRole{}, false, err
	}
	ret_identityRole, err := ScanIdentityRole(row)
	if err == sql.ErrNoRows {
		return identityRole{}, exists, nil
	} else if err == nil {
		exists = true
	}
	// Scan row to identityRole
	return ret_identityRole, exists, err
}

func updateIdentityRole(tx *goqu.TxDatabase, identityRoleId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "identity_role", tx.From("identity_role"))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToUpdateSql(q.fields))
	}
	// Execute query
	_, err := q.dataset.Update(q.fields).Exec()
	return errors.Wrap(err, "executing query")
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deleteIdentityRole(tx *goqu.TxDatabase, identityRoleId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "identity_role", tx.From("identity_role"))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToDeleteSql())
	}
	// Execute query
	_, err := q.dataset.Delete().Exec()
	return errors.Wrap(err, "executing query")
}

// ---------- ----------------- ----------
// ---------- ----------------- ----------
// ---------- identityWorkgroup ----------
// ---------- ----------------- ----------
// ---------- ----------------- ----------

func createIdentityWorkgroup(tx *goqu.TxDatabase, identityId, workgroupId int64, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "identity_workgroup", tx.From("identity_workgroup"))
	// Default insert fields
	identityWorkgroup := goqu.Record{
		"identity_id":  identityId,
		"workgroup_id": workgroupId,
	}
	q.AddFields(identityWorkgroup)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToInsertSql(q.fields))
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	return res.LastInsertId()
}

func readIdentityWorkgroups(tx *goqu.TxDatabase, options ...QueryOpt) ([]identityWorkgroup, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "identity_workgroup", tx.From("identity_workgroup"))
	for _, option := range options {
		if err := option(q); err != nil {
			return []identityWorkgroup{}, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []identityWorkgroup{}, err
	}
	defer rows.Close()

	// Scan rows to identityWorkgroups
	return ScanIdentityWorkgroups(rows)
}

func readIdentityWorkgroup(tx *goqu.TxDatabase, options ...QueryOpt) (identityWorkgroup, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "identity_workgroup", tx.From("identity_workgroup"))
	for _, option := range options {
		if err := option(q); err != nil {
			return identityWorkgroup{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return identityWorkgroup{}, false, err
	}
	ret_identityWorkgroup, err := ScanIdentityWorkgroup(row)
	if err == sql.ErrNoRows {
		return identityWorkgroup{}, exists, nil
	} else if err == nil {
		exists = true
	}
	// Scan row to identityWorkgroup
	return ret_identityWorkgroup, exists, err
}

func updateIdentityWorkgroup(tx *goqu.TxDatabase, identityWorkgroupId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "identity_workgroup", tx.From("identity_workgroup"))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToUpdateSql(q.fields))
	}
	// Execute query
	_, err := q.dataset.Update(q.fields).Exec()
	return errors.Wrap(err, "executing query")
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deleteIdentityWorkgroup(tx *goqu.TxDatabase, identityWorkgroupId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "identity_workgroup", tx.From("identity_workgroup"))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToDeleteSql())
	}
	// Execute query
	_, err := q.dataset.Delete().Exec()
	return errors.Wrap(err, "executing query")
}

// ---------- ------------- ----------
// ---------- ------------- ----------
// ---------- modelCategory ----------
// ---------- ------------- ----------
// ---------- ------------- ----------

func createModelCategory(tx *goqu.TxDatabase, name string, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "model_category", tx.From("model_category"))
	// Default insert fields
	modelCategory := goqu.Record{
		"name": name,
	}
	q.AddFields(modelCategory)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToInsertSql(q.fields))
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	return res.LastInsertId()
}

func readModelCategories(tx *goqu.TxDatabase, options ...QueryOpt) ([]modelCategory, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "model_category", tx.From("model_category"))
	for _, option := range options {
		if err := option(q); err != nil {
			return []modelCategory{}, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []modelCategory{}, err
	}
	defer rows.Close()

	// Scan rows to modelCategories
	return ScanModelCategorys(rows)
}

func readModelCategory(tx *goqu.TxDatabase, options ...QueryOpt) (modelCategory, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "model_category", tx.From("model_category"))
	for _, option := range options {
		if err := option(q); err != nil {
			return modelCategory{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return modelCategory{}, false, err
	}
	ret_modelCategory, err := ScanModelCategory(row)
	if err == sql.ErrNoRows {
		return modelCategory{}, exists, nil
	} else if err == nil {
		exists = true
	}
	// Scan row to modelCategory
	return ret_modelCategory, exists, err
}

func updateModelCategory(tx *goqu.TxDatabase, modelCategoryId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "model_category", tx.From("model_category").Where(goqu.I("id").Eq(modelCategoryId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToUpdateSql(q.fields))
	}
	// Execute query
	_, err := q.dataset.Update(q.fields).Exec()
	return errors.Wrap(err, "executing query")
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deleteModelCategory(tx *goqu.TxDatabase, modelCategoryId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "model_category", tx.From("model_category").Where(goqu.I("id").Eq(modelCategoryId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToDeleteSql())
	}
	// Execute query
	_, err := q.dataset.Delete().Exec()
	return errors.Wrap(err, "executing query")
}

// ---------- ---------- ----------
// ---------- ---------- ----------
// ---------- Permission ----------
// ---------- ---------- ----------
// ---------- ---------- ----------

func (ds *Datastore) CreatePermission(code, description string, options ...QueryOpt) (int64, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return 0, errors.Wrap(err, "beginning transaction")
	}

	var id int64
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "permission", tx.From("permission"))
		// Default insert fields
		permission := goqu.Record{
			"code":        code,
			"description": description,
		}
		q.AddFields(permission)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToInsertSql(q.fields))
		}
		// Execute query
		res, err := q.dataset.Insert(q.fields).Exec()
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		id, err = res.LastInsertId()
		q.result = id
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		// Create audit for entity
		if q.audit {
			json, err := json.Marshal(q.fields)
			if err != nil {
				return errors.Wrap(err, "serializing metadata")
			}
			_, err = createHistory(q.tx, CreateOp, q.pz.Id(), q.entityType.Permission, id,
				WithDescription(string(json)),
			)
			return errors.Wrap(err, "creating audit entry")
		}

		return nil
	})

	return id, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadPermissions(options ...QueryOpt) ([]Permission, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return []Permission{}, errors.Wrap(err, "beginning transaction")
	}

	var permissions []Permission
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "permission", tx.From("permission"))
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToSql())
		}
		// Execute query
		rows, err := getRows(tx, q.dataset)
		if err != nil {
			return err
		}
		defer rows.Close()
		permissions, err = ScanPermissions(rows)

		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return permissions, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadPermission(options ...QueryOpt) (Permission, bool, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return Permission{}, false, errors.Wrap(err, "beginning transaction")
	}

	var permission Permission
	var exists bool
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "permission", tx.From("permission"))
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToSql())
		}
		// Execute query
		row, err := getRow(tx, q.dataset)
		if err != nil {
			return err
		}
		permission, err = ScanPermission(row)
		if err == sql.ErrNoRows {
			return nil
		} else if err == nil {
			exists = true
		}
		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return permission, exists, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) UpdatePermission(permissionId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "permission", tx.From("permission").Where(goqu.I("id").Eq(permissionId)))
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToUpdateSql(q.fields))
		}
		// Execute query
		_, err := q.dataset.Update(q.fields).Exec()
		return errors.Wrap(err, "executing query")
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}
		if q.audit {
			json, err := json.Marshal(q.fields)
			if err != nil {
				return errors.Wrap(err, "serializing metadata")
			}
			_, err = createHistory(q.tx, UpdateOp, q.pz.Id(), q.entityType.Permission, permissionId,
				WithDescription(string(json)),
			)
			return errors.Wrap(err, "creating audit entry")
		}
		return nil
	})

	return errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) DeletePermission(permissionId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "permission", tx.From("permission").Where(goqu.I("id").Eq(permissionId)))
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToDeleteSql())
		}
		// Execute query
		_, err := q.dataset.Delete().Exec()
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		if q.audit {
			json, err := json.Marshal(q.fields)
			if err != nil {
				return errors.Wrap(err, "serializing metadata")
			}
			_, err = createHistory(q.tx, DeleteOp, q.pz.Id(), q.entityType.Permission, permissionId,
				WithDescription(string(json)),
			)
			return errors.Wrap(err, "creating audit entry")
		}
		return nil
	})

	return errors.Wrap(err, "committing transaction")
}
func createPermission(tx *goqu.TxDatabase, code, description string, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "permission", tx.From("permission"))
	// Default insert fields
	permission := goqu.Record{
		"code":        code,
		"description": description,
	}
	q.AddFields(permission)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToInsertSql(q.fields))
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	return res.LastInsertId()
}

func readPermissions(tx *goqu.TxDatabase, options ...QueryOpt) ([]Permission, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "permission", tx.From("permission"))
	for _, option := range options {
		if err := option(q); err != nil {
			return []Permission{}, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []Permission{}, err
	}
	defer rows.Close()

	// Scan rows to Permissions
	return ScanPermissions(rows)
}

func readPermission(tx *goqu.TxDatabase, options ...QueryOpt) (Permission, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "permission", tx.From("permission"))
	for _, option := range options {
		if err := option(q); err != nil {
			return Permission{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return Permission{}, false, err
	}
	ret_permission, err := ScanPermission(row)
	if err == sql.ErrNoRows {
		return Permission{}, exists, nil
	} else if err == nil {
		exists = true
	}
	// Scan row to Permission
	return ret_permission, exists, err
}

func updatePermission(tx *goqu.TxDatabase, permissionId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "permission", tx.From("permission").Where(goqu.I("id").Eq(permissionId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToUpdateSql(q.fields))
	}
	// Execute query
	_, err := q.dataset.Update(q.fields).Exec()
	return errors.Wrap(err, "executing query")
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deletePermission(tx *goqu.TxDatabase, permissionId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "permission", tx.From("permission").Where(goqu.I("id").Eq(permissionId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToDeleteSql())
	}
	// Execute query
	_, err := q.dataset.Delete().Exec()
	return errors.Wrap(err, "executing query")
}

// ---------- --------- ----------
// ---------- --------- ----------
// ---------- Privilege ----------
// ---------- --------- ----------
// ---------- --------- ----------

func (ds *Datastore) CreatePrivilege(typ string, workgroupId, entityType, entityId int64, options ...QueryOpt) (int64, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return 0, errors.Wrap(err, "beginning transaction")
	}

	var id int64
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "privilege", tx.From("privilege"))
		// Default insert fields
		privilege := goqu.Record{
			"privilege_type": typ,
			"workgroup_id":   workgroupId,
			"entity_type_id": entityType,
			"entity_id":      entityId,
		}
		q.AddFields(privilege)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToInsertSql(q.fields))
		}
		// Execute query
		res, err := q.dataset.Insert(q.fields).Exec()
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		id, err = res.LastInsertId()
		q.result = id
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		// Create audit for entity
		if q.audit {
			json, err := json.Marshal(q.fields)
			if err != nil {
				return errors.Wrap(err, "serializing metadata")
			}
			_, err = createHistory(q.tx, CreateOp, q.pz.Id(), q.entityType.Privilege, id,
				WithDescription(string(json)),
			)
			return errors.Wrap(err, "creating audit entry")
		}

		return nil
	})

	return id, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadPrivileges(options ...QueryOpt) ([]Privilege, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return []Privilege{}, errors.Wrap(err, "beginning transaction")
	}

	var privileges []Privilege
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "privilege", tx.From("privilege"))
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToSql())
		}
		// Execute query
		rows, err := getRows(tx, q.dataset)
		if err != nil {
			return err
		}
		defer rows.Close()
		privileges, err = ScanPrivileges(rows)

		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return privileges, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadPrivilege(options ...QueryOpt) (Privilege, bool, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return Privilege{}, false, errors.Wrap(err, "beginning transaction")
	}

	var privilege Privilege
	var exists bool
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "privilege", tx.From("privilege"))
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToSql())
		}
		// Execute query
		row, err := getRow(tx, q.dataset)
		if err != nil {
			return err
		}
		privilege, err = ScanPrivilege(row)
		if err == sql.ErrNoRows {
			return nil
		} else if err == nil {
			exists = true
		}
		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return privilege, exists, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) UpdatePrivilege(privilegeId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "privilege", tx.From("privilege").Where(goqu.I("id").Eq(privilegeId)))
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToUpdateSql(q.fields))
		}
		// Execute query
		_, err := q.dataset.Update(q.fields).Exec()
		return errors.Wrap(err, "executing query")
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}
		if q.audit {
			json, err := json.Marshal(q.fields)
			if err != nil {
				return errors.Wrap(err, "serializing metadata")
			}
			_, err = createHistory(q.tx, UpdateOp, q.pz.Id(), q.entityType.Privilege, privilegeId,
				WithDescription(string(json)),
			)
			return errors.Wrap(err, "creating audit entry")
		}
		return nil
	})

	return errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) DeletePrivilege(privilegeId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "privilege", tx.From("privilege").Where(goqu.I("id").Eq(privilegeId)))
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToDeleteSql())
		}
		// Execute query
		_, err := q.dataset.Delete().Exec()
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		if q.audit {
			json, err := json.Marshal(q.fields)
			if err != nil {
				return errors.Wrap(err, "serializing metadata")
			}
			_, err = createHistory(q.tx, DeleteOp, q.pz.Id(), q.entityType.Privilege, privilegeId,
				WithDescription(string(json)),
			)
			return errors.Wrap(err, "creating audit entry")
		}
		return nil
	})

	return errors.Wrap(err, "committing transaction")
}
func createPrivilege(tx *goqu.TxDatabase, typ string, workgroupId, entityType, entityId int64, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "privilege", tx.From("privilege"))
	// Default insert fields
	privilege := goqu.Record{
		"privilege_type": typ,
		"workgroup_id":   workgroupId,
		"entity_type_id": entityType,
		"entity_id":      entityId,
	}
	q.AddFields(privilege)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToInsertSql(q.fields))
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	return res.LastInsertId()
}

func readPrivileges(tx *goqu.TxDatabase, options ...QueryOpt) ([]Privilege, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "privilege", tx.From("privilege"))
	for _, option := range options {
		if err := option(q); err != nil {
			return []Privilege{}, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []Privilege{}, err
	}
	defer rows.Close()

	// Scan rows to Privileges
	return ScanPrivileges(rows)
}

func readPrivilege(tx *goqu.TxDatabase, options ...QueryOpt) (Privilege, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "privilege", tx.From("privilege"))
	for _, option := range options {
		if err := option(q); err != nil {
			return Privilege{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return Privilege{}, false, err
	}
	ret_privilege, err := ScanPrivilege(row)
	if err == sql.ErrNoRows {
		return Privilege{}, exists, nil
	} else if err == nil {
		exists = true
	}
	// Scan row to Privilege
	return ret_privilege, exists, err
}

func updatePrivilege(tx *goqu.TxDatabase, privilegeId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "privilege", tx.From("privilege").Where(goqu.I("id").Eq(privilegeId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToUpdateSql(q.fields))
	}
	// Execute query
	_, err := q.dataset.Update(q.fields).Exec()
	return errors.Wrap(err, "executing query")
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deletePrivilege(tx *goqu.TxDatabase, privilegeId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "privilege", tx.From("privilege").Where(goqu.I("id").Eq(privilegeId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToDeleteSql())
	}
	// Execute query
	_, err := q.dataset.Delete().Exec()
	return errors.Wrap(err, "executing query")
}

// ---------- ------- ----------
// ---------- ------- ----------
// ---------- Project ----------
// ---------- ------- ----------
// ---------- ------- ----------

func (ds *Datastore) CreateProject(name, description, modelCategory string, options ...QueryOpt) (int64, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return 0, errors.Wrap(err, "beginning transaction")
	}

	var id int64
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "project", tx.From("project"))
		// Default insert fields
		project := goqu.Record{
			"name":           name,
			"description":    description,
			"model_category": modelCategory,
			"created":        time.Now(),
		}
		q.AddFields(project)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToInsertSql(q.fields))
		}
		// Execute query
		res, err := q.dataset.Insert(q.fields).Exec()
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		id, err = res.LastInsertId()
		q.result = id
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		// Create audit for entity
		if q.audit {
			json, err := json.Marshal(q.fields)
			if err != nil {
				return errors.Wrap(err, "serializing metadata")
			}
			_, err = createHistory(q.tx, CreateOp, q.pz.Id(), q.entityType.Project, id,
				WithDescription(string(json)),
			)
			return errors.Wrap(err, "creating audit entry")
		}

		return nil
	})

	return id, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadProjects(options ...QueryOpt) ([]Project, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return []Project{}, errors.Wrap(err, "beginning transaction")
	}

	var projects []Project
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "project", tx.From("project"))
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToSql())
		}
		// Execute query
		rows, err := getRows(tx, q.dataset)
		if err != nil {
			return err
		}
		defer rows.Close()
		projects, err = ScanProjects(rows)

		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return projects, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadProject(options ...QueryOpt) (Project, bool, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return Project{}, false, errors.Wrap(err, "beginning transaction")
	}

	var project Project
	var exists bool
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "project", tx.From("project"))
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToSql())
		}
		// Execute query
		row, err := getRow(tx, q.dataset)
		if err != nil {
			return err
		}
		project, err = ScanProject(row)
		if err == sql.ErrNoRows {
			return nil
		} else if err == nil {
			exists = true
		}
		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return project, exists, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) UpdateProject(projectId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "project", tx.From("project").Where(goqu.I("id").Eq(projectId)))
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToUpdateSql(q.fields))
		}
		// Execute query
		_, err := q.dataset.Update(q.fields).Exec()
		return errors.Wrap(err, "executing query")
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}
		if q.audit {
			json, err := json.Marshal(q.fields)
			if err != nil {
				return errors.Wrap(err, "serializing metadata")
			}
			_, err = createHistory(q.tx, UpdateOp, q.pz.Id(), q.entityType.Project, projectId,
				WithDescription(string(json)),
			)
			return errors.Wrap(err, "creating audit entry")
		}
		return nil
	})

	return errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) DeleteProject(projectId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "project", tx.From("project").Where(goqu.I("id").Eq(projectId)))
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToDeleteSql())
		}
		// Execute query
		_, err := q.dataset.Delete().Exec()
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		if q.audit {
			json, err := json.Marshal(q.fields)
			if err != nil {
				return errors.Wrap(err, "serializing metadata")
			}
			_, err = createHistory(q.tx, DeleteOp, q.pz.Id(), q.entityType.Project, projectId,
				WithDescription(string(json)),
			)
			return errors.Wrap(err, "creating audit entry")
		}
		return nil
	})

	return errors.Wrap(err, "committing transaction")
}
func createProject(tx *goqu.TxDatabase, name, description, modelCategory string, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "project", tx.From("project"))
	// Default insert fields
	project := goqu.Record{
		"name":           name,
		"description":    description,
		"model_category": modelCategory,
		"created":        time.Now(),
	}
	q.AddFields(project)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToInsertSql(q.fields))
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	return res.LastInsertId()
}

func readProjects(tx *goqu.TxDatabase, options ...QueryOpt) ([]Project, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "project", tx.From("project"))
	for _, option := range options {
		if err := option(q); err != nil {
			return []Project{}, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []Project{}, err
	}
	defer rows.Close()

	// Scan rows to Projects
	return ScanProjects(rows)
}

func readProject(tx *goqu.TxDatabase, options ...QueryOpt) (Project, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "project", tx.From("project"))
	for _, option := range options {
		if err := option(q); err != nil {
			return Project{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return Project{}, false, err
	}
	ret_project, err := ScanProject(row)
	if err == sql.ErrNoRows {
		return Project{}, exists, nil
	} else if err == nil {
		exists = true
	}
	// Scan row to Project
	return ret_project, exists, err
}

func updateProject(tx *goqu.TxDatabase, projectId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "project", tx.From("project").Where(goqu.I("id").Eq(projectId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToUpdateSql(q.fields))
	}
	// Execute query
	_, err := q.dataset.Update(q.fields).Exec()
	return errors.Wrap(err, "executing query")
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deleteProject(tx *goqu.TxDatabase, projectId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "project", tx.From("project").Where(goqu.I("id").Eq(projectId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToDeleteSql())
	}
	// Execute query
	_, err := q.dataset.Delete().Exec()
	return errors.Wrap(err, "executing query")
}

// ---------- ---- ----------
// ---------- ---- ----------
// ---------- Role ----------
// ---------- ---- ----------
// ---------- ---- ----------

func (ds *Datastore) CreateRole(name string, options ...QueryOpt) (int64, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return 0, errors.Wrap(err, "beginning transaction")
	}

	var id int64
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "role", tx.From("role"))
		// Default insert fields
		role := goqu.Record{
			"name":    name,
			"created": time.Now(),
		}
		q.AddFields(role)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToInsertSql(q.fields))
		}
		// Execute query
		res, err := q.dataset.Insert(q.fields).Exec()
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		id, err = res.LastInsertId()
		q.result = id
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		// Create audit for entity
		if q.audit {
			json, err := json.Marshal(q.fields)
			if err != nil {
				return errors.Wrap(err, "serializing metadata")
			}
			_, err = createHistory(q.tx, CreateOp, q.pz.Id(), q.entityType.Role, id,
				WithDescription(string(json)),
			)
			return errors.Wrap(err, "creating audit entry")
		}

		return nil
	})

	return id, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadRoles(options ...QueryOpt) ([]Role, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return []Role{}, errors.Wrap(err, "beginning transaction")
	}

	var roles []Role
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "role", tx.From("role"))
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToSql())
		}
		// Execute query
		rows, err := getRows(tx, q.dataset)
		if err != nil {
			return err
		}
		defer rows.Close()
		roles, err = ScanRoles(rows)

		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return roles, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadRole(options ...QueryOpt) (Role, bool, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return Role{}, false, errors.Wrap(err, "beginning transaction")
	}

	var role Role
	var exists bool
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "role", tx.From("role"))
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToSql())
		}
		// Execute query
		row, err := getRow(tx, q.dataset)
		if err != nil {
			return err
		}
		role, err = ScanRole(row)
		if err == sql.ErrNoRows {
			return nil
		} else if err == nil {
			exists = true
		}
		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return role, exists, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) UpdateRole(roleId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "role", tx.From("role").Where(goqu.I("id").Eq(roleId)))
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToUpdateSql(q.fields))
		}
		// Execute query
		_, err := q.dataset.Update(q.fields).Exec()
		return errors.Wrap(err, "executing query")
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}
		if q.audit {
			json, err := json.Marshal(q.fields)
			if err != nil {
				return errors.Wrap(err, "serializing metadata")
			}
			_, err = createHistory(q.tx, UpdateOp, q.pz.Id(), q.entityType.Role, roleId,
				WithDescription(string(json)),
			)
			return errors.Wrap(err, "creating audit entry")
		}
		return nil
	})

	return errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) DeleteRole(roleId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "role", tx.From("role").Where(goqu.I("id").Eq(roleId)))
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToDeleteSql())
		}
		// Execute query
		_, err := q.dataset.Delete().Exec()
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		if q.audit {
			json, err := json.Marshal(q.fields)
			if err != nil {
				return errors.Wrap(err, "serializing metadata")
			}
			_, err = createHistory(q.tx, DeleteOp, q.pz.Id(), q.entityType.Role, roleId,
				WithDescription(string(json)),
			)
			return errors.Wrap(err, "creating audit entry")
		}
		return nil
	})

	return errors.Wrap(err, "committing transaction")
}
func createRole(tx *goqu.TxDatabase, name string, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "role", tx.From("role"))
	// Default insert fields
	role := goqu.Record{
		"name":    name,
		"created": time.Now(),
	}
	q.AddFields(role)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToInsertSql(q.fields))
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	return res.LastInsertId()
}

func readRoles(tx *goqu.TxDatabase, options ...QueryOpt) ([]Role, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "role", tx.From("role"))
	for _, option := range options {
		if err := option(q); err != nil {
			return []Role{}, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []Role{}, err
	}
	defer rows.Close()

	// Scan rows to Roles
	return ScanRoles(rows)
}

func readRole(tx *goqu.TxDatabase, options ...QueryOpt) (Role, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "role", tx.From("role"))
	for _, option := range options {
		if err := option(q); err != nil {
			return Role{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return Role{}, false, err
	}
	ret_role, err := ScanRole(row)
	if err == sql.ErrNoRows {
		return Role{}, exists, nil
	} else if err == nil {
		exists = true
	}
	// Scan row to Role
	return ret_role, exists, err
}

func updateRole(tx *goqu.TxDatabase, roleId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "role", tx.From("role").Where(goqu.I("id").Eq(roleId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToUpdateSql(q.fields))
	}
	// Execute query
	_, err := q.dataset.Update(q.fields).Exec()
	return errors.Wrap(err, "executing query")
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deleteRole(tx *goqu.TxDatabase, roleId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "role", tx.From("role").Where(goqu.I("id").Eq(roleId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToDeleteSql())
	}
	// Execute query
	_, err := q.dataset.Delete().Exec()
	return errors.Wrap(err, "executing query")
}

// ---------- -------------- ----------
// ---------- -------------- ----------
// ---------- rolePermission ----------
// ---------- -------------- ----------
// ---------- -------------- ----------

func createRolePermission(tx *goqu.TxDatabase, roleId, permissionId int64, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "role_permission", tx.From("role_permission"))
	// Default insert fields
	rolePermission := goqu.Record{
		"role_id":       roleId,
		"permission_id": permissionId,
	}
	q.AddFields(rolePermission)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToInsertSql(q.fields))
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	return res.LastInsertId()
}

func readRolePermissions(tx *goqu.TxDatabase, options ...QueryOpt) ([]rolePermission, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "role_permission", tx.From("role_permission"))
	for _, option := range options {
		if err := option(q); err != nil {
			return []rolePermission{}, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []rolePermission{}, err
	}
	defer rows.Close()

	// Scan rows to rolePermissions
	return ScanRolePermissions(rows)
}

func readRolePermission(tx *goqu.TxDatabase, options ...QueryOpt) (rolePermission, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "role_permission", tx.From("role_permission"))
	for _, option := range options {
		if err := option(q); err != nil {
			return rolePermission{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return rolePermission{}, false, err
	}
	ret_rolePermission, err := ScanRolePermission(row)
	if err == sql.ErrNoRows {
		return rolePermission{}, exists, nil
	} else if err == nil {
		exists = true
	}
	// Scan row to rolePermission
	return ret_rolePermission, exists, err
}

func updateRolePermission(tx *goqu.TxDatabase, rolePermissionId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "role_permission", tx.From("role_permission"))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToUpdateSql(q.fields))
	}
	// Execute query
	_, err := q.dataset.Update(q.fields).Exec()
	return errors.Wrap(err, "executing query")
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deleteRolePermission(tx *goqu.TxDatabase, rolePermissionId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "role_permission", tx.From("role_permission"))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToDeleteSql())
	}
	// Execute query
	_, err := q.dataset.Delete().Exec()
	return errors.Wrap(err, "executing query")
}

// ---------- ----- ----------
// ---------- ----- ----------
// ---------- state ----------
// ---------- ----- ----------
// ---------- ----- ----------

func createState(tx *goqu.TxDatabase, name string, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "state", tx.From("state"))
	// Default insert fields
	state := goqu.Record{
		"name": name,
	}
	q.AddFields(state)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToInsertSql(q.fields))
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	return res.LastInsertId()
}

func readStates(tx *goqu.TxDatabase, options ...QueryOpt) ([]state, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "state", tx.From("state"))
	for _, option := range options {
		if err := option(q); err != nil {
			return []state{}, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []state{}, err
	}
	defer rows.Close()

	// Scan rows to states
	return ScanStates(rows)
}

func readState(tx *goqu.TxDatabase, options ...QueryOpt) (state, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "state", tx.From("state"))
	for _, option := range options {
		if err := option(q); err != nil {
			return state{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return state{}, false, err
	}
	ret_state, err := ScanState(row)
	if err == sql.ErrNoRows {
		return state{}, exists, nil
	} else if err == nil {
		exists = true
	}
	// Scan row to state
	return ret_state, exists, err
}

func updateState(tx *goqu.TxDatabase, stateId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "state", tx.From("state").Where(goqu.I("id").Eq(stateId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToUpdateSql(q.fields))
	}
	// Execute query
	_, err := q.dataset.Update(q.fields).Exec()
	return errors.Wrap(err, "executing query")
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deleteState(tx *goqu.TxDatabase, stateId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "state", tx.From("state").Where(goqu.I("id").Eq(stateId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToDeleteSql())
	}
	// Execute query
	_, err := q.dataset.Delete().Exec()
	return errors.Wrap(err, "executing query")
}

// ---------- ------- ----------
// ---------- ------- ----------
// ---------- Service ----------
// ---------- ------- ----------
// ---------- ------- ----------

func (ds *Datastore) CreateService(projectId, modelId int64, name string, options ...QueryOpt) (int64, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return 0, errors.Wrap(err, "beginning transaction")
	}

	var id int64
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "service", tx.From("service"))
		// Default insert fields
		service := goqu.Record{
			"project_id": projectId,
			"model_id":   modelId,
			"name":       name,
			"state":      q.state.Starting,
			"created":    time.Now(),
		}
		q.AddFields(service)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToInsertSql(q.fields))
		}
		// Execute query
		res, err := q.dataset.Insert(q.fields).Exec()
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		id, err = res.LastInsertId()
		q.result = id
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		// Create audit for entity
		if q.audit {
			json, err := json.Marshal(q.fields)
			if err != nil {
				return errors.Wrap(err, "serializing metadata")
			}
			_, err = createHistory(q.tx, CreateOp, q.pz.Id(), q.entityType.Service, id,
				WithDescription(string(json)),
			)
			return errors.Wrap(err, "creating audit entry")
		}

		return nil
	})

	return id, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadServices(options ...QueryOpt) ([]Service, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return []Service{}, errors.Wrap(err, "beginning transaction")
	}

	var services []Service
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "service", tx.From("service"))
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToSql())
		}
		// Execute query
		rows, err := getRows(tx, q.dataset)
		if err != nil {
			return err
		}
		defer rows.Close()
		services, err = ScanServices(rows)

		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return services, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadService(options ...QueryOpt) (Service, bool, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return Service{}, false, errors.Wrap(err, "beginning transaction")
	}

	var service Service
	var exists bool
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "service", tx.From("service"))
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToSql())
		}
		// Execute query
		row, err := getRow(tx, q.dataset)
		if err != nil {
			return err
		}
		service, err = ScanService(row)
		if err == sql.ErrNoRows {
			return nil
		} else if err == nil {
			exists = true
		}
		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return service, exists, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) UpdateService(serviceId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "service", tx.From("service").Where(goqu.I("id").Eq(serviceId)))
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToUpdateSql(q.fields))
		}
		// Execute query
		_, err := q.dataset.Update(q.fields).Exec()
		return errors.Wrap(err, "executing query")
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}
		if q.audit {
			json, err := json.Marshal(q.fields)
			if err != nil {
				return errors.Wrap(err, "serializing metadata")
			}
			_, err = createHistory(q.tx, UpdateOp, q.pz.Id(), q.entityType.Service, serviceId,
				WithDescription(string(json)),
			)
			return errors.Wrap(err, "creating audit entry")
		}
		return nil
	})

	return errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) DeleteService(serviceId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "service", tx.From("service").Where(goqu.I("id").Eq(serviceId)))
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToDeleteSql())
		}
		// Execute query
		_, err := q.dataset.Delete().Exec()
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		if q.audit {
			json, err := json.Marshal(q.fields)
			if err != nil {
				return errors.Wrap(err, "serializing metadata")
			}
			_, err = createHistory(q.tx, DeleteOp, q.pz.Id(), q.entityType.Service, serviceId,
				WithDescription(string(json)),
			)
			return errors.Wrap(err, "creating audit entry")
		}
		return nil
	})

	return errors.Wrap(err, "committing transaction")
}
func createService(tx *goqu.TxDatabase, projectId, modelId int64, name string, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "service", tx.From("service"))
	// Default insert fields
	service := goqu.Record{
		"project_id": projectId,
		"model_id":   modelId,
		"name":       name,
		"state":      q.state.Starting,
		"created":    time.Now(),
	}
	q.AddFields(service)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToInsertSql(q.fields))
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	return res.LastInsertId()
}

func readServices(tx *goqu.TxDatabase, options ...QueryOpt) ([]Service, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "service", tx.From("service"))
	for _, option := range options {
		if err := option(q); err != nil {
			return []Service{}, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []Service{}, err
	}
	defer rows.Close()

	// Scan rows to Services
	return ScanServices(rows)
}

func readService(tx *goqu.TxDatabase, options ...QueryOpt) (Service, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "service", tx.From("service"))
	for _, option := range options {
		if err := option(q); err != nil {
			return Service{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return Service{}, false, err
	}
	ret_service, err := ScanService(row)
	if err == sql.ErrNoRows {
		return Service{}, exists, nil
	} else if err == nil {
		exists = true
	}
	// Scan row to Service
	return ret_service, exists, err
}

func updateService(tx *goqu.TxDatabase, serviceId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "service", tx.From("service").Where(goqu.I("id").Eq(serviceId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToUpdateSql(q.fields))
	}
	// Execute query
	_, err := q.dataset.Update(q.fields).Exec()
	return errors.Wrap(err, "executing query")
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deleteService(tx *goqu.TxDatabase, serviceId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "service", tx.From("service").Where(goqu.I("id").Eq(serviceId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToDeleteSql())
	}
	// Execute query
	_, err := q.dataset.Delete().Exec()
	return errors.Wrap(err, "executing query")
}

// ---------- --------- ----------
// ---------- --------- ----------
// ---------- Workgroup ----------
// ---------- --------- ----------
// ---------- --------- ----------

func (ds *Datastore) CreateWorkgroup(typ, name string, options ...QueryOpt) (int64, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return 0, errors.Wrap(err, "beginning transaction")
	}

	var id int64
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "workgroup", tx.From("workgroup"))
		// Default insert fields
		workgroup := goqu.Record{
			"type":    typ,
			"name":    name,
			"created": time.Now(),
		}
		q.AddFields(workgroup)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToInsertSql(q.fields))
		}
		// Execute query
		res, err := q.dataset.Insert(q.fields).Exec()
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		id, err = res.LastInsertId()
		q.result = id
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		// Create audit for entity
		if q.audit {
			json, err := json.Marshal(q.fields)
			if err != nil {
				return errors.Wrap(err, "serializing metadata")
			}
			_, err = createHistory(q.tx, CreateOp, q.pz.Id(), q.entityType.Workgroup, id,
				WithDescription(string(json)),
			)
			return errors.Wrap(err, "creating audit entry")
		}

		return nil
	})

	return id, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadWorkgroups(options ...QueryOpt) ([]Workgroup, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return []Workgroup{}, errors.Wrap(err, "beginning transaction")
	}

	var workgroups []Workgroup
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "workgroup", tx.From("workgroup"))
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToSql())
		}
		// Execute query
		rows, err := getRows(tx, q.dataset)
		if err != nil {
			return err
		}
		defer rows.Close()
		workgroups, err = ScanWorkgroups(rows)

		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return workgroups, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadWorkgroup(options ...QueryOpt) (Workgroup, bool, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return Workgroup{}, false, errors.Wrap(err, "beginning transaction")
	}

	var workgroup Workgroup
	var exists bool
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "workgroup", tx.From("workgroup"))
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToSql())
		}
		// Execute query
		row, err := getRow(tx, q.dataset)
		if err != nil {
			return err
		}
		workgroup, err = ScanWorkgroup(row)
		if err == sql.ErrNoRows {
			return nil
		} else if err == nil {
			exists = true
		}
		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return workgroup, exists, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) UpdateWorkgroup(workgroupId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "workgroup", tx.From("workgroup").Where(goqu.I("id").Eq(workgroupId)))
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToUpdateSql(q.fields))
		}
		// Execute query
		_, err := q.dataset.Update(q.fields).Exec()
		return errors.Wrap(err, "executing query")
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}
		if q.audit {
			json, err := json.Marshal(q.fields)
			if err != nil {
				return errors.Wrap(err, "serializing metadata")
			}
			_, err = createHistory(q.tx, UpdateOp, q.pz.Id(), q.entityType.Workgroup, workgroupId,
				WithDescription(string(json)),
			)
			return errors.Wrap(err, "creating audit entry")
		}
		return nil
	})

	return errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) DeleteWorkgroup(workgroupId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "workgroup", tx.From("workgroup").Where(goqu.I("id").Eq(workgroupId)))
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if DEBUG {
			log.Println(q.dataset.ToDeleteSql())
		}
		// Execute query
		_, err := q.dataset.Delete().Exec()
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		if q.audit {
			json, err := json.Marshal(q.fields)
			if err != nil {
				return errors.Wrap(err, "serializing metadata")
			}
			_, err = createHistory(q.tx, DeleteOp, q.pz.Id(), q.entityType.Workgroup, workgroupId,
				WithDescription(string(json)),
			)
			return errors.Wrap(err, "creating audit entry")
		}
		return nil
	})

	return errors.Wrap(err, "committing transaction")
}
func createWorkgroup(tx *goqu.TxDatabase, typ, name string, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "workgroup", tx.From("workgroup"))
	// Default insert fields
	workgroup := goqu.Record{
		"type":    typ,
		"name":    name,
		"created": time.Now(),
	}
	q.AddFields(workgroup)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToInsertSql(q.fields))
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	return res.LastInsertId()
}

func readWorkgroups(tx *goqu.TxDatabase, options ...QueryOpt) ([]Workgroup, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "workgroup", tx.From("workgroup"))
	for _, option := range options {
		if err := option(q); err != nil {
			return []Workgroup{}, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []Workgroup{}, err
	}
	defer rows.Close()

	// Scan rows to Workgroups
	return ScanWorkgroups(rows)
}

func readWorkgroup(tx *goqu.TxDatabase, options ...QueryOpt) (Workgroup, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "workgroup", tx.From("workgroup"))
	for _, option := range options {
		if err := option(q); err != nil {
			return Workgroup{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return Workgroup{}, false, err
	}
	ret_workgroup, err := ScanWorkgroup(row)
	if err == sql.ErrNoRows {
		return Workgroup{}, exists, nil
	} else if err == nil {
		exists = true
	}
	// Scan row to Workgroup
	return ret_workgroup, exists, err
}

func updateWorkgroup(tx *goqu.TxDatabase, workgroupId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "workgroup", tx.From("workgroup").Where(goqu.I("id").Eq(workgroupId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToUpdateSql(q.fields))
	}
	// Execute query
	_, err := q.dataset.Update(q.fields).Exec()
	return errors.Wrap(err, "executing query")
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deleteWorkgroup(tx *goqu.TxDatabase, workgroupId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "workgroup", tx.From("workgroup").Where(goqu.I("id").Eq(workgroupId)))
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if DEBUG {
		log.Println(q.dataset.ToDeleteSql())
	}
	// Execute query
	_, err := q.dataset.Delete().Exec()
	return errors.Wrap(err, "executing query")
}
