package main

const src = `
{{- define "main" -}}
// GENERATED BY crudgen; DON'T EDIT

package {{.Name}}

import (
	"database/sql"
	"log"
	"time"

	"github.com/pkg/errors"
	"gopkg.in/doug-martin/goqu.v3"
)

var DEBUG bool

{{range .Tables -}}
// ---------- {{range strLen .Name}}-{{end}} ----------
// ---------- {{range strLen .Name}}-{{end}} ----------
// ---------- {{.Name}} ----------
// ---------- {{range strLen .Name}}-{{end}} ----------
// ---------- {{range strLen .Name}}-{{end}} ----------

{{if .IsExported}}{{template "exported" .}}{{end}}{{template "private" .}}


{{end}}{{end}}

{{define "begin" -}} {{/* ARG OPTIONAL */ -}}
	tx, err := ds.db.Begin()
	if err != nil {
		return {{if .}}{{.}}, {{end}}errors.Wrap(err, "beginning transaction")
	}
{{- end}}

{{define "options" -}} {{/* ARG OPTIONAL */ -}}
	for _, option := range options {
		if err := option(q); err != nil {
			return {{if .}}{{.}}, {{end}}errors.Wrap(err, "setting up query options")
		}
	}
{{- end}}

{{define "postFunc" -}}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
{{- end}}

{{define "metadata" -}}
	json, err := json.Marshal(q.fields)
	if err != nil {
		return errors.Wrap(err, "serializing metadata")
	}
{{- end}}

{{define "fields" -}} {{/* ARG REQUIRED */ -}}
	// Default insert fields
	{{toFieldVar .Name}} := goqu.Record{ 
		{{- range .Cols}}
		{{- if .IsArg}} 
		"{{.TblName}}": {{toFieldVar .Name}},
		{{- else if .Default}}
		"{{.TblName}}": {{.Default}},
		{{- end}}
		{{- end}}
	}
	q.AddFields({{toFieldVar .Name}})
{{- end}}

{{define "insertSql" -}} {{/* ARG OPTIONAL */ -}}
	if DEBUG {
		log.Println(q.dataset.ToInsertSql(q.fields))
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return {{if .}}{{.}}, {{end}}errors.Wrap(err, "executing query")
	}
	{{- if .}}{{/* Case for private */}}
	return res.LastInsertId()
	{{- else}}{{/* Case for exported */}}
	id, err = res.LastInsertId()
	if err != nil {
		return errors.Wrap(err, "retrieving id")
	}
	q.entityId = id
	{{template "postFunc"}}
	
	return nil
	{{- end}}
{{- end}}

{{define "toSql" -}}
	if DEBUG {
		log.Println(q.dataset.ToSql())
	}
{{- end}}

{{define "getRows" -}} {{/* ARG OPTIONAL */ -}}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return {{if .}}[]{{.Name}}{}, {{end}}err
	}
	defer rows.Close()
{{- end}}

{{define "scanRows" -}} {{/* ARG OPTIONAL */ -}}
	{{- if .}}{{/* Case for private */}}
	// Scan rows to {{( toPluralName .Name)}}s
	return Scan{{title .Name}}s(rows)
	{{- else}}{{/* Case for exported */}}
	if err != nil {
		return err
	}
	{{template "postFunc"}}

	return nil
	{{- end}}
{{- end}}

{{define "getRow" -}} {{/* ARG OPTIONAL */ -}}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return {{if .}}{{.Name}}{}, false, {{end}}err
	}
{{- end}}

{{define "scanRow" -}} {{/* ARG OPTIONAL */ -}}
	if err == sql.ErrNoRows {
		return {{if .}}{{.Name}}{}, exists, {{end}}nil
	} else if err == nil {
		exists = true
	}
	{{- if .}}{{/* Case for private */}}
	// Scan row to {{.Name}}
	return ret_{{lowerFirst .Name}}, exists, err
	{{- else}}{{/* Case for exported */}}
	if err != nil {
		return err
	}
	{{template "postFunc"}}

	return nil
	{{- end}}
{{- end}}

{{define "updateSql" -}} {{/* ARG OPTIONAL for exported */ -}}
	if DEBUG {
		log.Println(q.dataset.ToUpdateSql(q.fields))
	}
	// Execute query
	{{- if .}}{{/* Case for exported */}}
	if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
		return errors.Wrap(err, "executing query")
	}
	{{template "postFunc"}}
	return nil
	{{- else}}
	_, err := q.dataset.Update(q.fields).Exec()
	return errors.Wrap(err, "executing query")
	{{- end}}
{{- end}}

{{define "deleteSql" -}} {{/* ARG REQUIRED for exported */ -}}
	if DEBUG {
		log.Println(q.dataset.ToDeleteSql())
	}
	// Execute query
	{{- if .}}{{/* Case for exported */}}
	if _, err := q.dataset.Delete().Exec(); err != nil {
		return errors.Wrap(err, "executing query")
	}
	{{template "postFunc"}}
	return errors.Wrap(deletePrivilege(tx, ByEntityId(q.entityId), ByEntityTypeId(q.entityTypeId)), "deleting privileges")
	{{- else}} 
	_, err := q.dataset.Delete().Exec()
	return errors.Wrap(err, "executing query")
	{{- end}}
{{- end}}

{{- /* ----------------------------- */}}
{{- /* ----------------------------- */}}
{{- /* ----------------------------- */}}
{{- /* EXPORTED FUNCTIONS START HERE */}}
{{- /* ----------------------------- */}}
{{- /* ----------------------------- */}}
{{- /* ----------------------------- */}}

{{- define "exported" -}}

{{- /* CREATE EXPORTED */ -}}
func (ds *Datastore) Create{{title .Name}}({{toArgs .Cols}}options ...QueryOpt) (int64, error) {
	{{with "0"}}{{template "begin" .}}{{end}}
	
	var id int64
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, CreateOp, "{{lowerFirst (camelToSnake .Name)}}", nil)
		{{template "fields" .}}
		{{template "options"}}
		{{template "insertSql"}}
	})

	return id, errors.Wrap(err, "committing transaction")
}

{{/* READ MULTI EXPORTED */ -}}
func (ds *Datastore) Read{{title ( toPluralName .Name)}}s(options ...QueryOpt) ([]{{.Name}}, error) {
	{{with printf "[]%s{}" .Name}}{{template "begin" .}}{{end}}

	var {{lowerFirst ( toPluralName .Name)}}s []{{.Name}}
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "", "{{lowerFirst (camelToSnake .Name)}}", nil)
		{{template "options"}}
		{{template "toSql"}}
		{{template "getRows"}}
		{{lowerFirst ( toPluralName .Name)}}s, err = Scan{{title .Name}}s(rows)
		{{template "scanRows"}}
	})
	
	return {{lowerFirst ( toPluralName .Name)}}s, errors.Wrap(err, "committing transaction")
}

{{/* READ SINGLE EXPORTED */ -}}
func (ds *Datastore) Read{{title .Name}}(options ...QueryOpt) ({{.Name}}, bool, error) {
	{{with printf "%s{}, false" .Name}}{{template "begin" .}}{{end}}

	var {{lowerFirst .Name}} {{.Name}}
	var exists bool
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "", "{{lowerFirst (camelToSnake .Name)}}", nil)
		{{template "options"}}
		{{template "toSql"}}
		{{template "getRow"}}
		{{lowerFirst .Name}}, err = Scan{{title .Name}}(row)
		{{template "scanRow"}}
	})

	return {{lowerFirst .Name}}, exists, errors.Wrap(err, "committing transaction")
}

{{/* UPDATE EXPORTED */ -}}
func (ds *Datastore) Update{{title .Name}}({{if .Key}}{{lowerFirst .Name}}Id int64, {{end}}options ...QueryOpt) error {
	{{template "begin"}}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		{{- if .Key}}
		q := NewQueryConfig(ds, tx, UpdateOp, "{{lowerFirst (camelToSnake .Name)}}", {{lowerFirst .Name}}Id)
		{{- else}}
		q := NewQueryConfig(ds, tx, UpdateOp, "{{lowerFirst (camelToSnake .Name)}}", nil)
		{{- end}}
		{{template "options"}}
		{{template "updateSql" .}}
	})

	return errors.Wrap(err, "committing transaction")
}

{{/* DELETE EXPORTED */ -}}
func (ds *Datastore) Delete{{title .Name}}({{if .Key}}{{lowerFirst .Name}}Id int64, {{end}}options ...QueryOpt) error {
	{{template "begin"}}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		{{- if .Key}}
		q := NewQueryConfig(ds, tx, DeleteOp, "{{lowerFirst (camelToSnake .Name)}}", {{lowerFirst .Name}}Id)
		{{- else}}
		q := NewQueryConfig(ds, tx, DeleteOp, "{{lowerFirst (camelToSnake .Name)}}", nil)
		{{- end}}
		{{template "options"}}
		{{template "deleteSql" .}}
	})

	return errors.Wrap(err, "committing transaction")
}
{{end}} {{/* define "exported" */}}

{{- /* ---------------------------- */}}
{{- /* ---------------------------- */}}
{{- /* ---------------------------- */}}
{{- /* PRIVATE FUNCTIONS START HERE */}}
{{- /* ---------------------------- */}}
{{- /* ---------------------------- */}}
{{- /* ---------------------------- */}}

{{- define "private" -}}

{{- /* CREATE PRIVATE */ -}}
func create{{title .Name}}(tx *goqu.TxDatabase, {{toArgs .Cols}}options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, CreateOp, "{{lowerFirst (camelToSnake .Name)}}", nil)
	{{template "fields" .}}
	{{with "0"}}{{template "options" .}}{{end}}
	{{with "0"}}{{template "insertSql" .}}{{end}}
}

{{/* READ MULTI PRIVATE */ -}}
func read{{title ( toPluralName .Name)}}s(tx *goqu.TxDatabase, options ...QueryOpt) ([]{{.Name}}, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "{{lowerFirst (camelToSnake .Name)}}", nil)
	{{with printf "[]%s{}" .Name}}{{template "options" .}}{{end}}
	{{template "toSql"}}
	{{template "getRows" .}}
	{{template "scanRows" .}}
}

{{/* READ SINGLE PRIVATE */ -}}
func read{{title .Name}}(tx *goqu.TxDatabase, options ...QueryOpt) ({{.Name}}, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "{{lowerFirst (camelToSnake .Name)}}", nil)
	{{with printf "%s{}, exists" .Name}}{{template "options" .}}{{end}}
	{{template "toSql"}}
	{{template "getRow" .}}
	ret_{{lowerFirst .Name}}, err := Scan{{title .Name}}(row)
	{{template "scanRow" .}}
}

{{/* UPDATE PRIVATE */ -}}
func update{{title .Name}}(tx *goqu.TxDatabase, {{if .Key}}{{lowerFirst .Name}}Id int64, {{end}}options ...QueryOpt) error {
	// Setup query with optional parameters
	{{- if .Key}}
	q := NewQueryConfig(nil, tx, UpdateOp, "{{lowerFirst (camelToSnake .Name)}}", {{lowerFirst .Name}}Id)
	{{- else}}
	q := NewQueryConfig(nil, tx, UpdateOp, "{{lowerFirst (camelToSnake .Name)}}", nil)
	{{- end}}
	{{template "options"}}
	{{template "updateSql"}}
}

{{/* DELETE PRIVATE */ -}}
func delete{{title .Name}}(tx *goqu.TxDatabase, {{if .Key}}{{lowerFirst .Name}}Id int64, {{end}}options ...QueryOpt) error {
	// Setup query with optional parameters
	{{- if .Key}}
	q := NewQueryConfig(nil, tx, DeleteOp, "{{lowerFirst (camelToSnake .Name)}}", {{lowerFirst .Name}}Id)
	{{- else}}
	q := NewQueryConfig(nil, tx, DeleteOp, "{{lowerFirst (camelToSnake .Name)}}", nil)
	{{- end}}
	{{template "options"}}
	{{template "deleteSql"}}
}
{{end}}
`
